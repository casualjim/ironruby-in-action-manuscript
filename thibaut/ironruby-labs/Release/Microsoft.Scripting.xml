<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Scripting</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Scripting.Actions.Calls.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToExpression(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression},System.Boolean[])">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            If <c>null</c> is returned the argument is skipped (not passed to the callee).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.UpdateFromReturn(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.  May
            return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToReturnExpression(Microsoft.Scripting.Actions.Calls.ParameterBinder)">
            <summary>
            If the argument produces a return value (e.g. a ref or out value) this provides
            the additional value to be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.Type">
            <summary>
            Returns the type required for the argument or null if the ArgBuilder
            does not consume a type.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.ByRefArgument">
            <summary>
            An assignable value that is passed to a byref parameter
            After the call it will contain the updated value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingResult">
            <summary>
            Indicates the specific type of failure, if any, from binding to a method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.Success">
            <summary>
            The binding succeeded.  Only one method was applicable or had the best conversion.  
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.AmbiguousMatch">
            <summary>
            More than one method was applicable for the provided parameters and no method was considered the best.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.IncorrectArgumentCount">
            <summary>
            There are no overloads that match the number of parameters required for the call
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.CallFailure">
            <summary>
            None of the target method(s) can successfully be called.  The failure can be due to:
                1. Arguments could not be successfully converted for the call
                2. Keyword arguments could not be assigned to positional arguments
                3. Keyword arguments could be assigned but would result in an argument being assigned 
                   multiple times (keyword and positional arguments conflit or dupliate keyword arguments).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingTarget">
            <summary>
            Encapsulates the result of an attempt to bind to one or methods using the MethodBinder.
            
            Users should first check the Result property to see if the binding was successful or
            to determine the specific type of failure that occured.  If the binding was successful
            MakeExpression can then be called to create an expression which calls the method.
            If the binding was a failure callers can then create a custom error message based upon
            the reason the call failed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodTarget,Microsoft.Scripting.Actions.Calls.NarrowingLevel,System.Type[])">
            <summary>
            Creates a new BindingTarget when the method binding has succeeded
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodTarget,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Creates a new BindingTarget when the method binding has succeeded
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,System.Int32[])">
            <summary>
            Creates a new BindingTarget when the method binding has failed due to an incorrect argument count
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.CallFailure[])">
            <summary>
            Creates a new BindingTarget when the method binding has failued due to 
            one or more parameters which could not be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodTarget[])">
            <summary>
            Creates a new BindingTarget when the match was ambiguous
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression(Microsoft.Scripting.Actions.RuleBuilder,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            
            OBSOLETE
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            
            OBSOLETE
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression(Microsoft.Scripting.Actions.Calls.ParameterBinder)">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Result">
            <summary>
            Gets the result of the attempt to bind.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Method">
            <summary>
            Returns the method if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Name">
            <summary>
            Gets the name of the method as supplied to the MethodBinder.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.MethodTarget">
            <summary>
            Returns the MethodTarget if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.AmbiguousMatches">
            <summary>
            Returns the methods which don't have any matches or null if Result == BindingResult.AmbiguousMatch
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.CallFailures">
            <summary>
            Returns the methods and their associated conversion failures if Result == BindingResult.CallFailure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ExpectedArgumentCount">
            <summary>
            Returns the acceptable number of arguments which can be passed to the method if Result == BindingResult.IncorrectArgumentCount.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ActualArgumentCount">
            <summary>
            Returns the number of arguments provided to the call.  0 if the call succeeded or failed for a reason other
            than argument count mismatch.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ArgumentTests">
            <summary>
            Gets the type tests that need to be performed to ensure that a call is
            not applicable for an overload.
            
            The members of the array correspond to each of the arguments.  An element is 
            null if no test is necessary.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.RestrictedArguments">
            <summary>
            Gets the MetaObjects which we originally did binding against in their restricted form.
            
            The members of the array correspond to each of the arguments.  All members of the array
            have a value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ReturnType">
            <summary>
            Returns the return type of the binding, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.NarrowingLevel">
            <summary>
            Returns the NarrowingLevel of the method if the call succeeded.  If the call
            failed returns NarrowingLevel.None.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Success">
            <summary>
            Returns true if the binding was succesful, false if it failed.
            
            This is an alias for BindingTarget.Result == BindingResult.Success.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.CallFailure">
            <summary>
            Represents the reason why a call to a specific method could not be performed by the MethodBinder.
            
            The reason for the failure is specified by the CallFailureReason property.  Once this property
            has been consulted the other properties can be consulted for more detailed information regarding
            the failure.
            
            If reason is ConversionFailure the ConversionResults property will be non-null.
            If reason is UnassignableKeyword the KeywordArguments property will be non-null and include
                the keywords which could not be assigned.
            If reason is DuplicateKeyword the KeywordArguments property will be non-null and include
                the keywords which were duplicated (either by the keywords themselves or by positional
                arguments).
                
            MethodTarget is always set and indicates the method which failed to bind.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Target">
            <summary>
            Gets the MethodTarget which the call failed for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Reason">
            <summary>
            Gets the reason for the call failure which determines the other 
            properties of the CallFailure which should be consulted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.ConversionResults">
            <summary>
            Gets a list of ConversionResult's for each parameter indicating
            whether the conversion was successful or failed and the types
            being converted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.KeywordArguments">
            <summary>
            Gets the list of keyword arguments that were either dupliated or
            unassignable.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.None">
            <summary>
            Default value, their was no CallFailure.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.ConversionFailure">
            <summary>
            One of more parameters failed to be converted
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.UnassignableKeyword">
            <summary>
            One or more keyword arguments could not be successfully assigned to a positional argument
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.DuplicateKeyword">
            <summary>
            One or more keyword arguments were duplicated or would have taken the spot of a 
            provided positional argument.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ContextArgBuilder">
            <summary>
            ArgBuilder which provides the CodeContext parameter to a method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ConversionResult">
            <summary>
            Represents information about a failure to convert an argument from one
            type to another.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.DefaultArgBuilder">
            <summary>
            ArgBuilder which provides a default parameter value for a method call.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder">
            <summary>
            ArgBuilder which provides a value for a keyword argument.  
            
            The KeywordArgBuilder calculates its position at emit time using it's initial 
            offset within the keyword arguments, the number of keyword arguments, and the 
            total number of arguments provided by the user.  It then delegates to an 
            underlying ArgBuilder which only receives the single correct argument.
            
            Delaying the calculation of the position to emit time allows the method binding to be 
            done without knowing the exact the number of arguments provided by the user. Hence,
            the method binder can be dependent only on the set of method overloads and keyword names,
            but not the user arguments. While the number of user arguments could be determined
            upfront, the current MethodBinder does not have this design.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder.BuilderExpectsSingleParameter(Microsoft.Scripting.Actions.Calls.ArgBuilder)">
            <summary>
            The underlying builder should expect a single parameter as KeywordArgBuilder is responsible
            for calculating the correct parameter to use
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordConstructorReturnBuilder">
            <summary>
            Updates fields/properties of the returned value with unused keyword parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodBinder">
            <summary>
            Provides binding and overload resolution to .NET methods.
            
            MethodBinder's can be used for:
                generating new AST code for calling a method 
                calling a method via reflection at runtime
                (not implemented) performing an abstract call
                
            MethodBinder's support default arguments, optional arguments, by-ref (in and out), and keyword arguments.
            
            Implementation Details:
            
            The MethodBinder works by building up a TargetSet for each number of effective arguments that can be
            passed to a set of overloads.  For example a set of overloads such as:
                foo(object a, object b, object c)
                foo(int a, int b)
                
            would have 2 target sets - one for 3 parameters and one for 2 parameters.  For parameter arrays
            we fallback and create the appropriately sized TargetSet on demand.
            
            Each TargetSet consists of a set of MethodCandidate's.  Each MethodCandidate knows the flattened
            parameters that could be received.  For example for a function such as:
                foo(params int[] args)
                
            When this method is in a TargetSet of size 3 the MethodCandidate takes 3 parameters - all of them
            ints; if it's in a TargetSet of size 4 it takes 4 parameters.  Effectively a MethodCandidate is 
            a simplified view that allows all arguments to be treated as required positional arguments.
            
            Each MethodCandidate in turn refers to a MethodTarget.  The MethodTarget is composed of a set
            of ArgBuilder's and a ReturnBuilder which know how to consume the positional arguments and pass
            them to the appropriate argument of the destination method.  This includes routing keyword
            arguments to the correct position, providing the default values for optional arguments, etc...
            
            After binding is finished the MethodCandidates are thrown away and a BindingTarget is returned. 
            The BindingTarget indicates whether the binding was successful and if not any additional information
            that should be reported to the user about the failed binding.  It also exposes the MethodTarget which
            allows consumers to get the flattened list of required parameters for the call.  MethodCandidates
            are not exposed and are an internal implementation detail of the MethodBinder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBinder(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Collections.Generic.IList{System.Reflection.MethodBase})">
            <summary>
            Creates a new MethodBinder for binding to the specified methods that will attempt to bind
            at all defined NarrowingLevels.
            
            The provided ActionBinder is used for determining overload resolution.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBinder(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.SymbolId[])">
            <summary>
            Creates a new MethodBinder for binding to the specified methods on a call which includes keyword arguments that
            will attempt to bind at all defined NarrowingLevels.
            
            The provided ActionBinder is used for determining overload resolution.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBinder(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Creates a new MethodBinder for binding to the specified methods this will attempt to bind at 
            the specified NarrowingLevels.
            
            The provided ActionBinder is used for determining overload resolution.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBinder(Microsoft.Scripting.Actions.ActionBinder,System.String,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.SymbolId[],Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Creates a new MethodBinder for binding to the specified methods on a call which includes keyword arguments that
            will attempt to bind at the specified NarrowingLevels.
            
            The provided ActionBinder is used for determining overload resolution.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBindingTarget(Microsoft.Scripting.Runtime.CallTypes,System.Type[])">
            <summary>
            Creates a BindingTarget given the specified CallType and parameter types.
            
            The BindingTarget can then be tested for the success or particular type of
            failure that prevents the method from being called.  The BindingTarget can
            also be called reflectively at runtime, create an Expression for embedding in
            a RuleBuilder, or be used for performing an abstract call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodBinder.MakeBindingTarget(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Creates a BindingTarget given the specified CallType and parameter types.
            
            The BindingTarget can then be tested for the success or particular type of
            failure that prevents the method from being called.  The BindingTarget can
            also be called reflectively at runtime, create an Expression for embedding in
            a RuleBuilder, or be used for performing an abstract call.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.MethodBinder.Name">
            <summary>
            Gets the name of the MethodBinder as provided at construction time.
            
            The name may differ from the name of the underlying method bases if the
            language provides some mapping from .NET method names to language specific
            method names.  It is flowed through the MethodBinder primarily for error
            reporting purposes.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodBinder.TargetSet">
            <summary>
            Represents a collection of MethodCandidate's which all accept the
            same number of logical parameters.  For example a params method
            and a method with 3 parameters would both be a TargetSet for 3 parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodCandidate">
             <summary>
             MethodCandidate represents the different possible ways of calling a method or a set of method overloads.
             A single method can result in multiple MethodCandidates. Some reasons include:
             - Every optional parameter or parameter with a default value will result in a candidate
             - The presence of ref and out parameters will add a candidate for languages which want to return the updated values as return values.
             - ArgumentKind.List and ArgumentKind.Dictionary can result in a new candidate per invocation since the list might be different every time.
            
             Each MethodCandidate represents the parameter type for the candidate using ParameterWrapper.
             
             Contrast this with MethodTarget which represents the real physical invocation of a method
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodCandidate.MakeParamsExtended(Microsoft.Scripting.Actions.ActionBinder,System.Int32,Microsoft.Scripting.SymbolId[])">
            <summary>
            Builds a new MethodCandidate which takes count arguments and the provided list of keyword arguments.
            
            The basic idea here is to figure out which parameters map to params or a dictionary params and
            fill in those spots w/ extra ParameterWrapper's.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodTarget">
            <summary>
            MethodTarget represents how a method is bound to the arguments of the call-site
            
            Contrast this with MethodCandidate which represents the logical view of the invocation of a method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodTarget.MakeExpression(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression},System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates a call to this MethodTarget with the specified parameters.  Casts are inserted to force
            the types to the provided known types.
            
            TODO: Remove RuleBuilder and knownTypes once we're fully meta
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="parameters">The explicit arguments</param>
            <param name="knownTypes">If non-null, the type for each element in parameters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.NarrowingLevel">
            <summary>
            Narrowing conversions are conversions that cannot be proved to always succeed, conversions that are 
            known to possibly lose information, and conversions across domains of types sufficiently different 
            to merit narrowing notation like casts. 
            
            Its upto every language to define the levels for conversions. The narrowling levels can be used by
            for method overload resolution, where the overload is based on the parameter types (and not the number 
            of parameters).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.None">
            <summary>
            Conversions at this level do not do any narrowing. Typically, this will include
            implicit numeric conversions, Type.IsAssignableFrom, StringBuilder to string, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.One">
            <summary>
            Language defined prefered narrowing conversion.  First level that introduces narrowing
            conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Two">
            <summary>
            Language defined preferred narrowing conversion.  Second level that introduces narrowing
            conversions and should have more conversions than One.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Three">
            <summary>
            Language defined preferred narrowing conversion.  Third level that introduces narrowing
            conversions and should have more conversions that Two.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.All">
            <summary>
            A somewhat meaningful conversion is possible, but it will quite likely be lossy.
            For eg. BigInteger to an Int32, Boolean to Int32, one-char string to a char,
            larger number type to a smaller numeric type (where there is no overflow), etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.NullArgBuilder">
            <summary>
            ArgBuilder which always produces null.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OutArgBuilder">
            <summary>
            Builds the argument for an out argument when not passed a StrongBox.  The out parameter
            is returned as an additional return value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParameterBinder">
            <summary>
            Helper class for emitting calls via the MethodBinder.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParameterWrapper">
            <summary>
            ParameterWrapper represents the logical view of a parameter. For eg. the byref-reduced signature
            of a method with byref parameters will be represented using a ParameterWrapper of the underlying
            element type, since the logical view of the byref-reduced signature is that the argument will be
            passed by value (and the updated value is included in the return value).
            
            Contrast this with ArgBuilder which represents the real physical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterWrapper.#ctor(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.SymbolId,System.Boolean)">
            <summary>
            ParameterInfo is not available.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParamsDictArgBuilder">
            <summary>
            Builds the parameter for a params dictionary argument - this collects all the extra name/value
            pairs provided to the function into a SymbolDictionary which is passed to the function.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReferenceArgBuilder">
            <summary>
            An argument that the user wants to explicitly pass by-reference (with copy-in copy-out semantics).
            The user passes a StrongBox[T] object whose value will get updated when the call returns.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Type,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Parameter info is not available for this argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Reflection.ParameterInfo,System.Int32)">
            <summary>
            Type and whether the parameter is a params-array or params-dictionary is derived from info.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReturnReferenceArgBuilder">
            <summary>
            Builds a parameter for a reference argument when a StrongBox has not been provided.  The
            updated return value is returned as one of the resulting return values.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Interceptor">
            <summary>
            Interceptor prototype. The interceptor is a call site binder that wraps
            a real call site binder and can perform arbitrary operations on the expression
            trees that the wrapped binder produces:
              * Dumping the trees
              * Additional rewriting
              * Static compilation
              * ...
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Utils">
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Operator(Microsoft.Scripting.Actions.ActionBinder,Microsoft.Scripting.Runtime.Operators,System.Type,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Creates DynamicExpression representing OldDoOperationAction.
            </summary>
            <param name="binder">The binder responsible for binding the dynamic operation.</param>
            <param name="op">The operation to perform</param>
            <param name="resultType">Type of the result desired (The DynamicExpression is strongly typed)</param>
            <param name="arguments">Array of arguments for the action expression</param>
            <returns>New instance of the DynamicExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Create(Microsoft.Scripting.Actions.OldCreateInstanceAction,System.Type,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Creates DynamicExpression representing a CreateInstance action.
            </summary>
            <param name="action">The create instance action to perform.</param>
            <param name="result">Type of the result desired (The DynamicExpression is strongly typed)</param>
            <param name="arguments">Array of arguments for the action expression</param>
            <returns>New instance of the DynamicExpression</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.ConvertTo(Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Creates a new DynamicExpression which performs the specified conversion to the type.  The ActionExpress
            is strongly typed to the converted type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Generator(Microsoft.Linq.Expressions.LabelTarget,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates a generator with type IEnumerable{T}, where T is the label.Type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.TransformEnumerable(Microsoft.Linq.Expressions.Expression,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Linq.Expressions.ParameterExpression})">
            
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Coalesce(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.ParameterExpression@)">
            <summary>
            Null coalescing expression
            {result} ::= ((tmp = {_left}) == null) ? {right} : tmp
            '??' operator in C#.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo,Microsoft.Linq.Expressions.ParameterExpression@)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo,Microsoft.Linq.Expressions.ParameterExpression@)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(Microsoft.Scripting.Ast.LambdaBuilder,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(Microsoft.Scripting.Ast.LambdaBuilder,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.WeakConstant(System.Object)">
            <summary>
            Wraps the given value in a WeakReference and returns a tree that will retrieve
            the value from the WeakReference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Lambda(System.Type,System.String,Microsoft.Scripting.SourceSpan)">
            <summary>
            Creates new instance of the LambdaBuilder with specified name, return type and a source span.
            </summary>
            <param name="returnType">Return type of the lambda being built.</param>
            <param name="name">Name of the lambda being built.</param>
            <param name="span">SourceSpan for the lambda being built.</param>
            <returns>New instance of the </returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Lambda(System.Type,System.String)">
            <summary>
            Creates new instnace of the LambdaBuilder with specified name and a return type.
            </summary>
            <param name="returnType">Return type of the lambda being built.</param>
            <param name="name">Name for the lambda being built.</param>
            <returns>new LambdaBuilder instance</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.ComplexCallHelper(System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The complex call helper to create the AST method call node.
            Will add conversions (Expression.Convert()), deals with default parameter values and params arrays.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FinallyFlowControlExpression">
            <summary>
            Wrapping a tree in this node enables jumps from finally blocks
            It does this by generating control-flow logic in the tree
            
            Reducing this node requires a full tree walk of its body
            (but not nested lambdas)
            
            WARNING: this node cannot contain jumps across blocks, because it
            assumes any unknown jumps are jumps to an outer scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FlowControlRewriter">
            <summary>
            The purpose of this rewriter is simple: ETs do not allow jumps (break, continue, return, goto)
            that would go through a finally/fault. So we replace them with code that instead stores a flag,
            and then jumps to the end of the finally/fault. At the end of the try-finally, we emit a switch
            that then jumps to the correct label.
            
            A few things that make this more complicated:
            
              1. If a finally contains a jump out, then jumps in the try/catch need to be replaced as well.
                 It's to support cases like this:
                     # returns 234
                     def foo():
                         try: return 123
                         finally: return 234 
                 
                 We need to replace the "return 123" because after it jumps, we'll go to the finally, which
                 might decide to jump again, but once the IL finally exits, it ignores the finally jump and
                 keeps going with the original jump. The moral of the story is: if any jumps in finally are
                 rewritten, try/catch jumps must be also.
                 
             2. To generate better code, we only have one state variable, so if we have to jump out of
                multiple finallys we just keep jumping. It looks sort of like this:
                  foo:
                  try { ... } finally {
                      try { ... } finally {
                        ...
                        if (...) {
                            // was: goto foo;
                            $flow = 1; goto endInnerFinally; 
                        }
                        ...
                        endInnerFinally:
                      }
                      switch ($flow) {
                          case 1: goto endOuterFinally;
                      }
                      ...
                      endOuterFinally:
                  }
                  switch ($flow) {
                    case 1: $flow = 0; goto foo;
                  }
                  ...
            
            TODO: the compiler could optimize the switch/goto pattern, but it doesn't yet
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceFileInformation">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.FileName">
            <summary>
            The source file name
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.LanguageGuid">
            <summary>
            Returns the language's unique identifier, if any
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.VendorGuid">
            <summary>
            Returns the language vendor's unique identifier, if any
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.IDispatchMethodIndices">
            <summary>
            Layout of the IDispatch vtable
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComParamDesc">
            <summary>
            The parameter description of a method defined in a type library
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@,System.String)">
            <summary>
            Creates a representation for the paramter of a COM method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@)">
            <summary>
            Creates a representation for the return value of a COM method
            TODO: Return values should be represented by a different type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.ComInterop.ComParamDesc.DefaultValue">
            <summary>
            DBNull.Value if there is no default value
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComRuntimeHelpers.GetITypeInfoFromIDispatch(Microsoft.Scripting.ComInterop.IDispatch,System.Boolean)">
            <summary>
            Look for typeinfo using IDispatch.GetTypeInfo
            </summary>
            <param name="dispatch"></param>
            <param name="throwIfMissingExpectedTypeInfo">
            Some COM objects just dont expose typeinfo. In these cases, this method will return null.
            Some COM objects do intend to expose typeinfo, but may not be able to do so if the type-library is not properly 
            registered. This will be considered as acceptable or as an error condition depending on throwIfMissingExpectedTypeInfo</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComRuntimeHelpers.CheckIfMissingTypeInfoIsExpected(System.Int32,System.Boolean)">
            <summary>
            This method should be called when typeinfo is not available for an object. The function
            will check if the typeinfo is expected to be missing. This can include error cases where
            the same error is guaranteed to happen all the time, on all machines, under all circumstances.
            In such cases, we just have to operate without the typeinfo.
            
            However, if accessing the typeinfo is failing in a transient way, we might want to throw
            an exception so that we will eagerly predictably indicate the problem.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComTypeLibDesc.CreateFromGuid(System.Guid)">
            <summary>
            Reads the latest registered type library for the corresponding GUID,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicMetaObjectProvider that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="typeLibGuid">Type Library Guid</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComTypeLibDesc.CreateFromObject(System.Object)">
            <summary>
            Gets an ITypeLib object from OLE Automation compatible RCW ,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicMetaObjectProvider that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="rcw">OLE automation compatible RCW</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.GetManagedMarshalType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Gets the managed type that an object needs to be coverted to in order for it to be able
            to be represented as a Variant.
            
            In general, there is a many-to-many mapping between Type and VarEnum. However, this method
            returns a simple mapping that is needed for the current implementation. The reason for the 
            many-to-many relation is:
            1. Int32 maps to VT_I4 as well as VT_ERROR, and Decimal maps to VT_DECIMAL and VT_CY. However,
               this changes if you throw the wrapper types into the mix.
            2. There is no Type to represent COM types. __ComObject is a private type, and Object is too
               general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.IsPrimitiveType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Primitive types are the basic COM types. It includes valuetypes like ints, but also reference tyeps
            like BStrs. It does not include composite types like arrays and user-defined COM types (IUnknown/IDispatch).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ErrorSinkProxyListener">
            <summary>
            Bridges ErrorListener and ErrorSink. It provides the reverse functionality as ErrorSinkProxyListener
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ErrorListener">
            <summary>
            The host can use this class to track for errors reported during script parsing and compilation.
            Hosting API counterpart for <see cref="T:Microsoft.Scripting.ErrorSink"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.ICommandDispatcher">
            <summary>
            Used to dispatch a single interactive command. It can be used to control things like which Thread
            the command is executed on, how long the command is allowed to execute, etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager">
             <summary>
             Supports detecting the remote runtime being killed, and starting up a new one.
             
             Threading model:
             
             ConsoleRestartManager creates a separate thread on which to create and execute the consoles. 
             There are usually atleast three threads involved:
             
             1. Main app thread: Instantiates ConsoleRestartManager and accesses its APIs. This thread has to stay 
                responsive to user input and so the ConsoleRestartManager APIs cannot be long-running or blocking.
                Since the remote runtime process can terminate asynchronously, the current RemoteConsoleHost can 
                change at any time (if auto-restart is enabled). The app should typically not care which instance of 
                RemoteConsoleHost is currently being used. The flowchart of this thread is:
                    Create ConsoleRestartManager
                    ConsoleRestartManager.Start
                    Loop:
                        Respond to user input | Send user input to console for execution | BreakExecution | RestartConsole | GetMemberNames
                    ConsoleRestartManager.Terminate
                TODO: Currently, BreakExecution and GetMemberNames are called by the main thread synchronously.
                Since they execute code in the remote runtime, they could take arbitrarily long. We should change
                this so that the main app thread can never be blocked indefinitely.
            
             2. Console thread: Dedicated thread for creating RemoteConsoleHosts and executing code (which could
                take a long time or block indefinitely).
                    Wait for ConsoleRestartManager.Start to be called
                    Loop:
                        Create RemoteConsoleHost
                        Wait for signal for:
                             Execute code | RestartConsole | Process.Exited
            
             3. CompletionPort async callbacks:
                    Process.Exited | Process.OutputDataReceived | Process.ErrorDataReceived
             
             4. Finalizer thred
                Some objects may have a Finalize method (which possibly calls Dispose). Not many (if any) types
                should have a Finalize method.
             
             </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager._accessLock">
            <summary>
            Accessing _remoteConsoleHost from a thread other than console thread can result in race.
            If _remoteConsoleHost is accessed while holding _accessLock, it is guaranteed to be
            null or non-disposed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.#ctor(System.Boolean)">
            <summary>
            This is created on the "creating thread", and goes on standby. Start needs to be called for activation.
            </summary>
            <param name="exitOnNormalExit">A host might want one of two behaviors:
            1. Keep the REPL loop alive indefinitely, even when a specific instance of the RemoteConsoleHost terminates normally
            2. Close the REPL loop when an instance of the RemoteConsoleHost terminates normally, and restart the loop
               only if the instance terminates abnormally.</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.Start">
            <summary>
            Needs to be called for activation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.Terminate">
            <summary>
            Request (from another thread) the console REPL loop to terminate
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher">
            <summary>
            This allows the RemoteConsoleHost to abort a long-running operation. The RemoteConsoleHost itself
            does not know which ThreadPool thread might be processing the remote call, and so it needs
            cooperation from the remote runtime server.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher.OutputCompleteMarker">
            <summary>
            Since OnOutputDataReceived is sent async, it can arrive late. The remote console
            cannot know if all output from the current command has been received. So
            RemoteCommandDispatcher writes out a marker to indicate the end of the output
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher.AbortCommand">
            <summary>
            Aborts the current active call to Execute by doing Thread.Abort
            </summary>
            <returns>true if a Thread.Abort was actually called. false if there is no active call to Execute</returns>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleCommandLine">
            <summary>
            Customize the CommandLine for remote scenarios
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.CommandLine">
            <summary>
            Command line hosting service.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.Run(Microsoft.Scripting.Hosting.ScriptEngine,Microsoft.Scripting.Hosting.Shell.IConsole,Microsoft.Scripting.Hosting.Shell.ConsoleOptions)">
            <summary>
            Executes the comand line - depending upon the options provided we will
            either run a single file, a single command, or enter the interactive loop.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.Run">
            <summary>
            Runs the command line.  Languages can override this to provide custom behavior other than:
                1. Running a single command
                2. Running a file
                3. Entering the interactive console loop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunFile(Microsoft.Scripting.Hosting.ScriptSource)">
            <summary>
            Runs the specified filename
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunInteractive">
            <summary>
            Starts the interactive loop.  Performs any initialization necessary before
            starting the loop and then calls RunInteractiveLoop to start the loop.
            
            Returns the exit code when the interactive loop is completed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunInteractiveLoop">
            <summary>
            Runs the interactive loop.  Repeatedly parse and run interactive actions
            until an exit code is received.  If any exceptions are unhandled displays
            them to the console
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.TryInteractiveAction">
            <summary>
            Attempts to run a single interaction and handle any language-specific
            exceptions.  Base classes can override this and call the base implementation
            surrounded with their own exception handling.
            
            Returns null if successful and execution should continue, or an exit code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunOneInteraction">
            <summary>
            Parses a single interactive command or a set of statements and executes it.  
            
            Returns null if successful and execution should continue, or the appropiate exit code.
            
            We check if the code read is an interactive command or statements is by checking for NewLine
            If the code contains NewLine, it's a set of statements (most probably from SendToConsole)
            If the code does not contain a NewLine, it's an interactive command typed by the user at the prompt
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.TreatAsBlankLine(System.String,System.Int32)">
            <summary>
            Private helper function to see if we should treat the current input as a blank link.
            
            We do this if we only have auto-indent text.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.ReadStatement(System.Boolean@)">
            <summary>
            Read a statement, which can potentially be a multiple-line statement suite (like a class declaration).
            </summary>
            <param name="continueInteraction">Should the console session continue, or did the user indicate 
            that it should be terminated?</param>
            <returns>Expression to evaluate. null for empty input</returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.GetNextAutoIndentSize(System.String)">
            <summary>
            Gets the next level for auto-indentation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.CommandLine.Scope">
            <summary>
            Scope is not remotable, and this only works in the same AppDomain.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleCommandLine.RemoteConsoleCommandDispatcher">
            <summary>
            CommandDispatcher to ensure synchronize output from the remote runtime
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost">
            <summary>
            ConsoleHost where the ScriptRuntime is hosted in a separate process (referred to as the remote runtime server)
            
            The RemoteConsoleHost spawns the remote runtime server and specifies an IPC channel name to use to communicate
            with each other. The remote runtime server creates and initializes a ScriptRuntime and a ScriptEngine, and publishes
            it over the specified IPC channel at a well-known URI. Note that the RemoteConsoleHost cannot easily participate
            in the initialization of the ScriptEngine as classes like LanguageContext are not remotable.
            
            The RemoteConsoleHost then starts the interactive loop and executes commands on the ScriptEngine over the remoting channel.
            The RemoteConsoleHost listens to stdout of the remote runtime server and echos it locally to the user.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.ConsoleHost">
            <summary>
            Core functionality to implement an interactive console. This should be derived for concrete implementations
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHost.Terminate(System.Int32)">
            <summary>
            Request (from another thread) the console REPL loop to terminate
            </summary>
            <param name="exitCode">The caller can specify the exitCode corresponding to the event triggering
            the termination. This will be returned from CommandLine.Run</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHost.Run(System.String[])">
            <summary>
            To be called from entry point.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleHost.ExeName">
            <summary>
            Console Host entry-point .exe name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.CustomizeRemoteRuntimeStartInfo(System.Diagnostics.ProcessStartInfo)">
            <summary>
            Allows the console to customize the environment variables, working directory, etc.
            </summary>
            <param name="processInfo">At the least, processInfo.FileName should be initialized</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.AbortCommand">
            <summary>
            Aborts the current active call to Execute by doing Thread.Abort
            </summary>
            <returns>true if a Thread.Abort was actually called. false if there is no active call to Execute</returns>
        </member>
        <member name="E:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.RemoteRuntimeExited">
            <summary>
            Called if the remote runtime process exits by itself. ie. without the remote console killing it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteRuntimeServer">
            <summary>
            The remote runtime server uses this class to publish an initialized ScriptEngine and ScriptRuntime 
            over a remoting channel.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteRuntimeServer.StartServer(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Publish objects so that the host can use it, and then block indefinitely (until the input stream is open).
            
            Note that we should publish only one object, and then have other objects be accessible from it. Publishing
            multiple objects can cause problems if the client does a call like "remoteProxy1(remoteProxy2)" as remoting
            will not be able to know if the server object for both the proxies is on the same server.
            </summary>
            <param name="remoteRuntimeChannelName">The IPC channel that the remote console expects to use to communicate with the ScriptEngine</param>
            <param name="scope">A intialized ScriptScope that is ready to start processing script commands</param>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightDelegateCreator">
            <summary>
            Manages creation of interpreted delegates. These delegates will get
            compiled if they are executed often enough.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.Compile(System.Object)">
            <summary>
            Create a compiled delegate for the LightLambda, and saves it so
            future calls to Run will execute the compiled code instead of
            interpreting.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.UpdateExecutionCount">
            <summary>
            Updates the execution count of this light delegate. If a certain
            threshold is reached, it will start a background compilation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LightLambda.Compiled">
            <summary>
            Set by LightDelegateCreator once the delegate is compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LightLambda.Closure">
            <summary>
            Used by LightDelegateCreator to set the delegate.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.Interpreter">
            A simple forth-style stack machine for executing Expression trees
            without the need to compile to IL and then invoke the JIT.  This trades
            off much faster compilation time for a slower execution performance.
            For code that is only run a small number of times this can be a 
            sweet spot.
            
            The core loop in the interpreter is the RunInstructions method.
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightGlobalRewriter">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor">
            <summary>
            Visits a LambdaExpression, replacing the constants with direct accesses
            to their StrongBox fields. This is very similar to what
            ExpressionQuoter does for LambdaCompiler.
            
            Also inserts debug information tracking similar to what the interpreter
            would do.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureVars">
            <summary>
            Indexes of variables into the closure array
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureArray">
            <summary>
            The variable that holds onto the StrongBox{object}[] closure from
            the interpreter
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._shadowedVars">
            <summary>
            A stack of variables that are defined in nested scopes. We search
            this first when resolving a variable in case a nested scope shadows
            one of our variable instances.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.BindLambda(Microsoft.Linq.Expressions.LambdaExpression,System.Collections.Generic.IList{Microsoft.Linq.Expressions.ParameterExpression},System.Boolean@)">
            <summary>
            Walks the lambda and produces a higher order function, which can be
            used to bind the lambda to a closure array from the interpreter.
            </summary>
            <param name="lambda">The lambda to bind.</param>
            <param name="closureVars">The variables that are closed over from an outer scope.</param>
            <param name="delegateTypeMatch">true if the delegate type is the same; false if it was changed to Func/Action.</param>
            <returns>A delegate that can be called to produce a delegate bound to the passed in closure array.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.MergedRuntimeVariables">
            <summary>
            Provides a list of variables, supporing read/write of the values
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ScriptCode">
            <summary>
            ScriptCode is an instance of compiled code that is bound to a specific LanguageContext
            but not a specific ScriptScope. The code can be re-executed multiple times in different
            scopes. Hosting API counterpart for this class is <c>CompiledCode</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ScriptCode.SaveToAssembly(System.String,Microsoft.Scripting.ScriptCode[])">
            <summary>
            This takes an assembly name including extension and saves the provided ScriptCode objects into the assembly.  
            
            The provided script codes can constitute code from multiple languages.  The assemblyName can be either a fully qualified 
            or a relative path.  The DLR will simply save the assembly to the desired location.  The assembly is created by the DLR and 
            if a file already exists than an exception is raised.  
            
            The DLR determines the internal format of the ScriptCode and the DLR can feel free to rev this as appropriate.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ScriptCode.LoadFromAssembly(Microsoft.Scripting.Runtime.ScriptDomainManager,System.Reflection.Assembly)">
            <summary>
            This will take an assembly object which the user has loaded and return a new set of ScriptCode�s which have 
            been loaded into the provided ScriptDomainManager.  
            
            If the language associated with the ScriptCode�s has not already been loaded the DLR will load the 
            LanguageContext into the ScriptDomainManager based upon the saved LanguageContext type.  
            
            If the LanguageContext or the version of the DLR the language was compiled against is unavailable a 
            TypeLoadException will be raised unless policy has been applied by the administrator to redirect bindings.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicNull">
            <summary>
            Represents the type of a null value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicNull.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers">
            <summary>
            These are some generally useful helper methods. Currently the only methods are those to
            cached boxed representations of commonly used primitive types so that they can be shared.
            This is useful to most dynamic languages that use object as a universal type.
            
            The methods in RuntimeHelepers are caleld by the generated code. From here the methods may
            dispatch to other parts of the runtime to get bulk of the work done, but the entry points
            should be here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.ShiftParamsArray``1(``0[],System.Int32)">
            <summary>
            Used by prologue code that is injected in lambdas to ensure that delegate signature matches what 
            lambda body expects. Such code typically unwraps subset of the params array manually, 
            but then passes the rest in bulk if lambda body also expects params array.
            
            This calls ArrayUtils.ShiftLeft, but performs additional checks that
            ArrayUtils.ShiftLeft assumes.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.LookupGlobalName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Called from generated code, helper to do a global name lookup
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.SetGlobalName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Called from generated code, helper to do global name assignment
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.LookupName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Called from generated code, helper to do name lookup
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.SetName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Called from generated code, helper to do name assignment
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.True">
            <summary>
            A singleton boxed boolean true.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.False">
             <summary>
            A singleton boxed boolean false.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.Int32ToObject(System.Int32)">
            <summary>
            Gets a singleton boxed value for the given integer if possible, otherwise boxes the integer.
            </summary>
            <param name="value">The value to box.</param>
            <returns>The boxed value.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.CreateInstance``1">
            <summary>
            Helper method to create an instance.  Work around for Silverlight where Activator.CreateInstance
            is SecuritySafeCritical.
            
            TODO: Why can't we just emit the right thing for default(T)?
            It's always null for reference types and it's well defined for value types
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorExpression">
            <summary>
            A parameterless generator, that is of type IEnumerable, IEnumerable{T},
            IEnumerator, or IEnumerator{T}. Its body can contain a series of
            YieldExpressions. Each call into MoveNext on the enumerator reenters
            the generator, and executes until it reaches a YieldReturn or YieldBreak
            expression
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Target">
            <summary>
            The label used by YieldBreak and YieldReturn expressions to yield
            from this generator
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Body">
            <summary>
            The body of the generator, which can contain YieldBreak and
            YieldReturn expressions
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorRewriter">
            <summary>
            When finding a yield return or yield break, this rewriter flattens out
            containing blocks, scopes, and expressions with stack state. All
            scopes encountered have their variables promoted to the generator's
            closure, so they survive yields.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.ToTemp(Microsoft.Linq.Expressions.Expression@)">
            <summary>
            Spills the right side into a temp, and replaces it with its temp.
            Returns the expression that initializes the temp.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.MakeAssign(Microsoft.Linq.Expressions.ParameterExpression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Makes an assignment to this variable. Pushes the assignment as far
            into the right side as possible, to allow jumps into it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.SymbolConstantExpression">
            <summary>
            Represents a SymbolId constant
            This node is reducible, and also rewritten by GlobalOptimizedRewriter
            
            TODO: this node exists so GlobalOptimizedRewriter can recognize and
            rewrite a strongly typed node. Once that functionality is gone it
            should go away.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.YieldExpression">
            <summary>
            Represents either a YieldBreak or YieldReturn in a GeneratorExpression
            If Value is non-null, it's a YieldReturn; otherwise it's a YieldBreak
            and executing it will stop enumeration of the generator, causing
            MoveNext to return false.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Value">
            <summary>
            The value yieled from this expression, if it is a yield return
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Target">
            <summary>
            The label used to yield from this generator
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.Check(Microsoft.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="expression">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.IsConstant(Microsoft.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type,System.Int32,Microsoft.Scripting.Generation.EmitArrayHelper)">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SaveSnippets">
            <summary>
            Save snippets to an assembly (see also SnippetsDirectory, SnippetsFileName).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.TypeGen.TypeInitializer">
            <summary>
            Gets the Compiler associated with the Type Initializer (cctor) creating it if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.LanguageOptions.GetStringCollectionOption(System.Collections.Generic.IDictionary{System.String,System.Object},System.String,System.Char[])">
            <summary>
            Reads an option whose value is expected to be a collection of non-null strings.
            Reaturns a read-only copy of the option's value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.LanguageOptions.InterpretedMode">
            <summary>
            Interpret code instead of emitting it.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.LanguageOptions.AdaptiveCompilation">
            <summary>
            Dynamically choose between interpreting, simple compilation and compilation
            that takes advantage of runtime history.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.LanguageOptions.ExceptionDetail">
            <summary>
             Display exception detail (callstack) when exception gets caught
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.LanguageOptions.PerfStats">
            <summary>
            Whether to gather performance statistics.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.LanguageOptions.SearchPaths">
            <summary>
            Initial file search paths provided by the host.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.MathResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitByte">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into byte.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitChar">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into char.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitDecimal">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into decimal.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitInt">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into int.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitLong">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into long.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitSByte">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into sbyte.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitShort">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into short.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitUInt">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into uint.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitULong">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into ulong.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitUShort">
            <summary>
              Looks up a localized string similar to big integer won&apos;t fit into ushort.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ComplexDivizionByZero">
            <summary>
              Looks up a localized string similar to complex division by zero.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ExpectedInteger">
            <summary>
              Looks up a localized string similar to expected integer.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.FormatNotImplemented">
            <summary>
              Looks up a localized string similar to format not implemented.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.InvalidArgument">
            <summary>
              Looks up a localized string similar to invalid argument.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.NonNegativePower">
            <summary>
              Looks up a localized string similar to power must be &gt;= 0.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.RadixGreaterThan36">
            <summary>
              Looks up a localized string similar to radix must be &lt;= 36.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.RadixLessThan2">
            <summary>
              Looks up a localized string similar to radix must be &gt;= 2.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallBinderHelper`1">
            <summary>
            Creates rules for performing method calls.  Currently supports calling built-in functions, built-in method descriptors (w/o 
            a bound value) and bound built-in method descriptors (w/ a bound value), delegates, types defining a "Call" method marked
            with SpecialName.
            </summary>
            <typeparam name="TAction">The specific type of CallAction</typeparam>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallBinderHelper`1.MakeArgumentExpressions">
            <summary>
            Gets expressions to access all the arguments. This includes the instance argument. Splat arguments are
            unpacked in the output. The resulting array is similar to Rule.Parameters (but also different in some ways)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallBinderHelper`1.MakeSplatTests">
            <summary>
            Makes test for param arrays and param dictionary parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallBinderHelper`1.GetArgumentNamesAndTypes(Microsoft.Scripting.SymbolId[]@,System.Type[]@)">
            <summary>
            Gets all of the argument names and types. The instance argument is not included
            </summary>
            <param name="argNames">The names correspond to the end of argTypes.
            ArgumentKind.Dictionary is unpacked in the return value.
            This is set to an array of size 0 if there are no keyword arguments</param>
            <param name="argTypes">Non named arguments are returned at the beginning.
            ArgumentKind.List is unpacked in the return value. </param>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallBinderHelper`1.Instance">
            <summary>
            The instance for the target method, or null if this is a non-instance call.
            
            If it is set, it will typically be set to extract the instance from the Callable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter">
            <summary>
            A tree rewriter which will find dynamic sites which consume dynamic sites and
            turn them into a single combo dynamic site.  The combo dynamic site will then run the
            individual meta binders and produce the resulting code in a single dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter.ComboDynamicSiteExpression">
            <summary>
            A reducible node which we use to generate the combo dynamic sites.  Each time we encounter
            a dynamic site we replace it with a ComboDynamicSiteExpression.  When a child of a dynamic site
            turns out to be a ComboDynamicSiteExpression we will then merge the child with the parent updating
            the binding mapping info.  If any of the inputs cause side effects then we'll stop the combination.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboBinder">
            <summary>
            A binder which can combine multiple binders into a single dynamic site.  The creator
            of this needs to perform the mapping of parameters, constants, and sub-site expressions
            and provide a List of BinderMappingInfo representing this data.  From there the ComboBinder
            just processes the list to create the resulting code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ParameterMappingInfo">
            <summary>
            Provides a mapping for inputs of combo action expressions.  The input can map
            to either an input of the new dynamic site, an input of a previous DynamicExpression,
            or a ConstantExpression which has been pulled out of the dynamic site arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.BinderMappingInfo">
            <summary>
            Contains the mapping information for a single Combo Binder.  This includes the original
            meta-binder and the mapping of parameters, sub-sites, and constants into the binding.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConditionalBuilder">
            <summary>
            Builds up a series of conditionals when the False clause isn't yet known.  We can
            keep appending conditions and if true's.  Each subsequent true branch becomes the
            false branch of the previous condition and body.  Finally a non-conditional terminating
            branch must be added.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddCondition(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Adds a new conditional and body.  The first call this becomes the top-level
            conditional, subsequent calls will have it added as false statement of the
            previous conditional.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.FinishCondition(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Adds the non-conditional terminating node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.GetMetaObject(Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Gets the resulting meta object for the full body.  FinishCondition
            must have been called.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddVariable(Microsoft.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a variable which will be scoped at the level of the final expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConvertToBinderHelper">
            <summary>
            BinderHelper for producing rules related to performing conversions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryConvertToObject(System.Type,System.Type)">
            <summary>
            Checks if the conversion is to object and produces a target if it is.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryAllConversions(System.Type,System.Type)">
            <summary>
            Checks if any conversions are available and if so builds the target for that conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryAssignableConversion(System.Type,System.Type)">
            <summary>
            Checks if the conversion can be handled by a simple cast.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryUserDefinedConversion(System.Type,System.Type)">
            <summary>
            Checks if the conversion can be handled by calling a user-defined conversion method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryOneConversion(System.Type,System.Type,System.Type,System.String,System.Boolean)">
            <summary>
            Helper that checkes both types to see if either one defines the specified conversion
            method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryUserDefinedConversion(System.Type,System.Type,Microsoft.Scripting.Actions.MemberGroup,System.Boolean)">
            <summary>
            Checks if any of the members of the MemberGroup provide the applicable conversion and 
            if so uses it to build a conversion rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryExtensibleConversion(System.Type,System.Type)">
            <summary>
            Checks if the conversion is to applicable by extracting the value from Extensible of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryImplicitNumericConversion(System.Type,System.Type)">
            <summary>
            Checks if there's an implicit numeric conversion for primitive data types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryNullableConversion(System.Type,System.Type)">
            <summary>
            Checks if there's a conversion to/from Nullable of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryEnumerableConversion(System.Type,System.Type)">
            <summary>
            Checks if there's a conversion to IEnumerator or IEnumerator of T via calling GetEnumerator
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryNullConversion(System.Type,System.Type)">
            <summary>
            Checks to see if there's a conversion of null to a reference type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryComConversion(System.Type,System.Type)">
            <summary>
            Checks to see if there's a conversion of System.__ComObject to an interface type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.TryExtraConversions(System.Type)">
            <summary>
            Checks for any extra conversions which aren't based upon the incoming type of the object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeErrorTarget">
            <summary>
            Helper to produce an error when a conversion cannot occur
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakePerfectMatchTarget">
            <summary>
            Helper to produce a rule when no conversion is required (the strong type of the expression
            input matches the type we're converting to)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeBoxingTarget(System.Type)">
            <summary>
            Helper to produce a rule which just boxes a value type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeConversionTarget(Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeExtensibleConversionTarget(Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.WrapForThrowingTry(System.Boolean,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Helper to wrap explicit conversion call into try/catch incase it throws an exception.  If
            it throws the default value is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeSimpleConversionTarget(System.Type,System.Type)">
            <summary>
            Helper to produce a rule when no conversion is required (the strong type of the expression
            input matches the type we're converting to or has an implicit conversion at the IL level)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeSimpleExtensibleConversionTarget(System.Type)">
            <summary>
            Helper to produce a rule when no conversion is required from an extensible type's
            underlying storage to the type we're converting to.  The type of extensible type
            matches the type we're converting to or has an implicit conversion at the IL level.
            </summary>
            <param name="toType"></param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeExtensibleTarget(System.Type)">
            <summary>
            Helper to extract the value from an Extensible of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeNullToNullableOfTTarget(System.Type)">
            <summary>
            Helper to convert a null value to nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeTToNullableOfTTarget(System.Type,System.Type)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeConvertingToTToNullableOfTTarget(System.Type)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.GetExtensibleValue(System.Type)">
            <summary>
            Helper to extract the Value of an Extensible of T from the
            expression being converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.GetUnderlyingType(System.Type)">
            <summary>
            Helper that checks if fromType is an Extensible of T or a subtype of 
            Extensible of T and if so returns the T.  Otherwise it returns fromType.
            
            This is used to treat extensible types the same as their underlying types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeIEnumerableTarget(System.Type)">
            <summary>
            Makes a conversion target which converts IEnumerable -> IEnumerator
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeIEnumeratorOfTTarget(System.Type,System.Type)">
            <summary>
            Makes a conversion target which converts IEnumerable of T to IEnumerator of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeNullTarget(System.Type)">
            <summary>
            Creates a target which returns null for a reference type.
            </summary>
            <param name="toType"></param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConvertToBinderHelper.MakeDelegateTarget(System.Type)">
            <summary>
            Creates a target which creates a new dynamic method which contains a single
            dynamic site that invokes the callable object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ActionBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeRule(Microsoft.Scripting.Actions.OldDynamicAction,System.Object[],Microsoft.Scripting.Actions.RuleBuilder)">
            <summary>
            Produces a rule for the specified Action for the given arguments.
            </summary>
            <param name="action">The Action that is being performed.</param>
            <param name="args">The arguments to the action as provided from the call site at runtime.</param>
            <param name="rule">The rule builder that will hold the result</param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.Convert(System.Object,System.Type)">
            <summary>
            Converts an object at runtime into the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.CanConvertFrom(System.Type,System.Type,System.Boolean,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Determines if a conversion exists from fromType to toType at the specified narrowing level.
            toNotNullable is true if the target variable doesn't allow null values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.SelectBestConversionFor(System.Type,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Selects the best (of two) candidates for conversion from actualType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ConvertExpression(Microsoft.Linq.Expressions.Expression,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Converts the provided expression to the given type.  The expression is safe to evaluate multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetMember(Microsoft.Scripting.Actions.OldDynamicAction,System.Type,System.String)">
            <summary>
            Gets the members that are visible from the provided type of the specified name.
            
            The default implemetnation first searches the type, then the flattened heirachy of the type, and then
            registered extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticAssignFromDerivedTypeError(System.Type,Microsoft.Scripting.Actions.MemberTracker,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Called when a set is attempting to assign to a field or property from a derived class through the base class.
            
            The default behavior is to allow the assignment.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticPropertyInstanceAccessError(Microsoft.Scripting.Actions.PropertyTracker,System.Boolean,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates an ErrorInfo object when a static property is accessed from an instance member.  The default behavior is throw
            an exception indicating that static members properties be accessed via an instance.  Languages can override this to 
            customize the exception, message, or to produce an ErrorInfo object which reads or writes to the property being accessed.
            </summary>
            <param name="tracker">The static property being accessed through an instance</param>
            <param name="isAssignment">True if the user is assigning to the property, false if the user is reading from the property</param>
            <param name="parameters">The parameters being used to access the property.  This includes the instance as the first entry, any index parameters, and the
            value being assigned as the last entry if isAssignment is true.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeMissingMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            
            Deprecated, use the non-generic version instead
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeReadOnlyMemberError(Microsoft.Scripting.Actions.RuleBuilder,System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeUndeletableMemberError(Microsoft.Scripting.Actions.RuleBuilder,System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetAllExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Base classes are also
            searched for their extension members.  Once any of the types in the inheritance hierarchy
            provide an extension member the search is stopped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Subclasses of the
            type and their extension members are not searched.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ReturnMemberTracker(System.Type,Microsoft.Scripting.Actions.MemberTracker)">
            <summary>
            Provides an opportunity for languages to replace all MemberInfo's with their own type.
            
            Alternatlely a language can expose MemberInfo's directly.
            </summary>
            <param name="memberTracker">The member which is being returned to the user.</param>
            <param name="type">Tthe type which the memberTrack was accessed from</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeCallExpression(Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IList{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Builds an expression for a call to the provided method using the given expressions.  If the
            method is not static the first parameter is used for the instance.
            
            Parameters are converted using the binder's conversion rules.
            
            If an incorrect number of parameters is provided MakeCallExpression returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetByRefArrayExpression(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Gets an expression that evaluates to the result of GetByRefArray operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.BindSpecialParameter(System.Reflection.ParameterInfo,System.Collections.Generic.List{Microsoft.Scripting.Actions.Calls.ArgBuilder},System.Collections.Generic.List{Microsoft.Scripting.Actions.Calls.ParameterWrapper},System.Int32@)">
            <summary>
            Handles binding of special parameters.
            </summary>
            <returns>True if the argument is handled by this method.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.PrepareParametersBinding(System.Reflection.ParameterInfo[],System.Collections.Generic.List{Microsoft.Scripting.Actions.Calls.ArgBuilder},System.Collections.Generic.List{Microsoft.Scripting.Actions.Calls.ParameterWrapper},System.Int32@)">
            <summary>
            Called before arguments binding.
            </summary>
            <returns>The number of parameter infos to skip.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryConvertToObject(System.Type,System.Type,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if the conversion is to object and produces a target if it is.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAllConversions(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if any conversions are available and if so builds the target for that conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAssignableConversion(System.Type,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by a simple cast.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by calling a user-defined conversion method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryOneConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,System.Type,System.String,System.Boolean,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper that checkes both types to see if either one defines the specified conversion
            method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,Microsoft.Scripting.Actions.MemberGroup,System.Boolean,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if any of the members of the MemberGroup provide the applicable conversion and 
            if so uses it to build a conversion rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryExtensibleConversion(System.Type,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if the conversion is to applicable by extracting the value from Extensible of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryImplicitNumericConversion(System.Type,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if there's an implicit numeric conversion for primitive data types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullableConversion(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Checks if there's a conversion to/from Nullable of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullConversion(System.Type,System.Type,Microsoft.Scripting.BindingRestrictions)">
            <summary>
            Checks to see if there's a conversion of null to a reference type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeErrorTarget(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce an error when a conversion cannot occur
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeBoxingTarget(Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce a rule which just boxes a value type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTargetWorker(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Boolean,Microsoft.Scripting.BindingRestrictions,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Helper to produce a conversion rule by calling the method to do the convert.  This version takes the parameter
            to be passed to the conversion function and we call it w/ our own value or w/ our Extensible.Value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.WrapForThrowingTry(Microsoft.Scripting.Actions.ConversionResultKind,System.Boolean,Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            Helper to wrap explicit conversion call into try/catch incase it throws an exception.  If
            it throws the default value is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleConversionTarget(System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required (the strong type of the expression
            input matches the type we're converting to or has an implicit conversion at the IL level)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleExtensibleConversionTarget(System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required from an extensible type's
            underlying storage to the type we're converting to.  The type of extensible type
            matches the type we're converting to or has an implicit conversion at the IL level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleTarget(System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to extract the value from an Extensible of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullToNullableOfTTarget(System.Type,Microsoft.Scripting.BindingRestrictions)">
            <summary>
            Helper to convert a null value to nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeTToNullableOfTTarget(System.Type,System.Type,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConvertingToTToNullableOfTTarget(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetExtensibleValue(System.Type,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Helper to extract the Value of an Extensible of T from the
            expression being converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetUnderlyingType(System.Type)">
            <summary>
            Helper that checks if fromType is an Extensible of T or a subtype of 
            Extensible of T and if so returns the T.  Otherwise it returns fromType.
            
            This is used to treat extensible types the same as their underlying types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullTarget(System.Type,Microsoft.Scripting.BindingRestrictions)">
            <summary>
            Creates a target which returns null for a reference type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.DeleteMember(System.String,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member delete.  Supports all built-in .NET members, the OperatorMethod 
            DeleteMember, and StrongBox instances.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorDeleteMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,Microsoft.Linq.Expressions.Expression,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,Microsoft.Scripting.DynamicMetaObject,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="codeContext">
            An expression which provides access to the CodeContext if its required for 
            accessing the member (e.g. for an extension property which takes CodeContext).  By default this
            a null CodeContext object is passed.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,Microsoft.Scripting.DynamicMetaObject,Microsoft.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="codeContext">
            An expression which provides access to the CodeContext if its required for 
            accessing the member (e.g. for an extension property which takes CodeContext).  By default this
            a null CodeContext object is passed.
            </param>
            <param name="isNoThrow">
            True if the operation should return Operation.Failed on failure, false if it
            should return the exception produced by MakeMissingMemberError.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorGetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo,Microsoft.Linq.Expressions.Expression,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The object to be called</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.Actions.Calls.ParameterBinder,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTargetInfo(Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Gets a TargetInfo object for performing a call on this object.  
            
            If this object is a delegate we bind to the Invoke method.
            If this object is a MemberGroup or MethodGroup we bind to the methods in the member group.
            If this object is a BoundMemberTracker we bind to the methods with the bound instance.
            If the underlying type has defined an operator Call method we'll bind to that method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMethodGroupTargets(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.Actions.MethodGroup)">
            <summary>
            Binds to the methods in a method group.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMemberGroupTargets(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.Actions.MemberGroup)">
            <summary>
            Binds to the methods in a member group.  
            
            TODO: We should really only have either MemberGroup or MethodGroup, not both.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetBoundMemberTargets(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],Microsoft.Scripting.Actions.BoundMemberTracker)">
            <summary>
            Binds to the BoundMemberTracker and uses the instance in the tracker and restricts
            based upon the object instance type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetDelegateTargets(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],System.Delegate)">
            <summary>
            Binds to the Invoke method on a delegate if this is a delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetOperatorTargets(Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject[],System.Object,Microsoft.Scripting.Actions.CallSignature)">
            <summary>
            Attempts to bind to an operator Call method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject})">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  All arguments 
            are treated as positional arguments.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  All arguments 
            are treated as positional arguments.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="maxLevel">The maximum narrowing level for arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>
            <param name="minLevel">The minimum narrowing level for the arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>        
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions,System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallInstanceMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.DynamicMetaObject,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments and the specified
            instance argument.  The arguments are consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="instance">The instance which will be provided for dispatching to an instance method.</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="maxLevel">The maximum narrowing level for arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>
            <param name="minLevel">The minimum narrowing level for the arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>        
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,System.String,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="maxLevel">The maximum narrowing level for arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>
            <param name="minLevel">The minimum narrowing level for the arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>        
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallInstanceMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.DynamicMetaObject,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments and the specified
            instance argument.  The arguments are consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="instance">The instance which will be provided for dispatching to an instance method.</param>
            <param name="maxLevel">The maximum narrowing level for arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>
            <param name="minLevel">The minimum narrowing level for the arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>        
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallInstanceMethod(Microsoft.Scripting.Actions.Calls.ParameterBinder,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.DynamicMetaObject,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.BindingRestrictions,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,System.String,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments and the specified
            instance argument.  The arguments are consumed as specified by the CallSignature object.
            </summary>
            <param name="parameterBinder">ParameterBinder used to map arguments to parameters.</param>
            <param name="targets">The methods to be called</param>
            <param name="args">The arguments for the call</param>
            <param name="signature">The call signature which specified how the arguments will be consumed</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="instance">The instance which will be provided for dispatching to an instance method.</param>
            <param name="maxLevel">The maximum narrowing level for arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>
            <param name="minLevel">The minimum narrowing level for the arguments.  The current narrowing level is flowed thorugh to the DefaultBinder.</param>        
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSplatTests(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject})">
            <summary>
            Makes test for param arrays and param dictionary parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsArrayTest(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject})">
            <summary>
            Pulls out the right argument to build the splat test.  MakeParamsTest makes the actual test.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsTest(System.Object,Microsoft.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Builds the restrictions for calling with a splatted argument array.  Ensures that the
            argument is still an ICollection of object and that it has the same number of arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsDictionaryTest(System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},System.Boolean)">
            <summary>
            Builds the restrictions for calling with keyword arguments.  The restrictions include
            tests on the individual keys of the dictionary to ensure they have the same names.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetArgumentNamesAndTypes(Microsoft.Scripting.Actions.CallSignature,System.Collections.Generic.IList{Microsoft.Scripting.DynamicMetaObject},Microsoft.Scripting.SymbolId[]@,Microsoft.Scripting.DynamicMetaObject[]@)">
            <summary>
            Gets all of the argument names and types. The instance argument is not included
            </summary>
            <param name="argNames">The names correspond to the end of argTypes.
            ArgumentKind.Dictionary is unpacked in the return value.
            This is set to an array of size 0 if there are no keyword arguments</param>
            <param name="resultingArgs">Non named arguments are returned at the beginning.
            ArgumentKind.List is unpacked in the return value. </param>
            <param name="args">The MetaObject array which has the arguments for the call</param>
            <param name="signature">The signature we're building the call for</param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetIndex(Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetIndex(Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeGeneralOperatorRule(System.String,Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Creates the meta object for the rest of the operations: comparisons and all other
            ExpressionType.  If the operation cannot be completed a MetaObject which indicates an
            error will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullComparisonRule(Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Produces a rule for comparing a value to null - supports comparing object references and nullable types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,Microsoft.Scripting.DynamicMetaObject,Microsoft.Scripting.DynamicMetaObject,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="codeContext">
            An expression which provides access to the CodeContext if its required for 
            accessing the member (e.g. for an extension property which takes CodeContext).  By default this
            a null CodeContext object is passed.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorSetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeRule(Microsoft.Scripting.Actions.OldDynamicAction,System.Object[],Microsoft.Scripting.Actions.RuleBuilder)">
            <summary>
            Produces a rule for the specified Action for the given arguments.
            
            The default implementation can produce rules for standard .NET types.  Languages should
            override this and provide any custom behavior they need and fallback to the default
            implementation if no custom behavior is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeUndeletableMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNonPublicMemberGetError(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.MemberTracker,System.Type,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Called when the user is accessing a protected or private member on a get.
            
            The default implementation allows access to the fields or properties using reflection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeReadOnlyMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.AllowKeywordArgumentSetting(System.Reflection.MethodBase)">
            <summary>
            Checks to see if the language allows keyword arguments to be bound to instance fields or
            properties and turned into sets.  By default this is only allowed on contructors.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.TargetInfo">
            <summary>
            Encapsulates information about the target of the call.  This includes an implicit instance for the call,
            the methods that we'll be calling as well as any restrictions required to perform the call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberBinderHelper`1.AddToBody(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Use this method to extend the Body.  It will create BlockStatements as needed.
            </summary>
            <param name="expression"></param>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberBinderHelper`1.Instance">
            <summary> Gets the Expression that represents the instance we're looking up </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberBinderHelper`1.StringName">
            <summary> helper to grab the name of the member we're looking up as a string </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberBinderHelper`1.Body">
            <summary>
            There is no setter on Body.  Use AddToBody to extend it instead.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DeleteMemberBinderHelper.MakeOperatorGetMemberBody(System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DoOperationBinderHelper.TryMakeNullComparisonRule">
            <summary>
            Produces a rule for comparing a value to null - supports comparing object references and nullable types.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.GetMemberBinderHelper">
            <summary>
            Builds a rule for a GetMemberAction.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            
            The RuleMaker sets up it's initial state grabbing the incoming type and the type we should look members up
            from.  It then does the lookup for the members using the current context's ActionBinder and then binds to
            the returned members if the match is non-ambiguous.  
            
            The target of the rule is built up using a series of block statements as the body.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.GetMemberBinderHelper.MakeOperatorGetMemberBody(System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.GetMemberBinderHelper.Instance">
            <summary> Gets the Expression that represents the instance we're looking up </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NoSideEffectsAttribute">
            <summary>
            Marks a method as not having side effects.  used by the combo binder
            to allow calls to methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.OperatorInfo">
            <summary>
            OperatorInfo provides a mapping from DLR ExpressionType to their associated .NET methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.OperatorInfo.GetOperatorInfo(Microsoft.Linq.Expressions.ExpressionType)">
            <summary>
            Given an operator returns the OperatorInfo associated with the operator or null
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Operator">
            <summary>
            The operator the OperatorInfo provides info for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Name">
            <summary>
            The primary method name associated with the method.  This method name is
            usally in the form of op_Operator (e.g. op_Addition).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.AlternateName">
            <summary>
            The secondary method name associated with the method.  This method name is
            usually a standard .NET method name with pascal casing (e.g. Add).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.SetMemberBinderHelper.MakeOperatorSetMemberBody(System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.AssignmentExtensionExpression">
            <summary>
            Evaluates to the CodeContext that's currently in scope
            
            TODO: this should go away as an intrinsic in favor of languages
                  tracking their own scope chain explicitly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.DeleteStatement">
            <summary>
            AST node representing deletion of the variable value.
            TODO: Python specific?
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.ExpressionHelpers.RemoveName(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Called from generated code, helper to remove a name
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaBuilder">
            <summary>
            The builder for creating the LambdaExpression node.
            
            Since the nodes require that parameters and variables are created
            before hand and then passed to the factories creating LambdaExpression
            this builder keeps track of the different pieces and at the end creates
            the LambdaExpression.
            
            TODO: This has some functionality related to CodeContext that should be
            removed, in favor of languages handling their own local scopes
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Parameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverParameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddParameters(Microsoft.Linq.Expressions.ParameterExpression[])">
            <summary>
            adds existing parameter to the lambda.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateHiddenParameter(System.String,System.Type)">
            <summary>
            Creates a hidden parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateParamsArray(System.Type,System.String)">
            <summary>
            Creates a params array argument on the labmda.
            
            The params array argument is added to the signature immediately. Before the lambda is
            created, the builder validates that it is still the last (since the caller can modify
            the order of parameters explicitly by maniuplating the parameter list)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverVariable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Variable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.HiddenVariable(System.Type,System.String)">
            <summary>
            Creates a temporary variable with specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddHiddenVariable(Microsoft.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds the temporary variable to the list of variables maintained
            by the builder. This is useful in cases where the variable is
            created outside of the builder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda(System.Type)">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <param name="lambdaType">Desired type of the lambda. </param>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeGenerator(Microsoft.Linq.Expressions.LabelTarget,System.Type)">
            <summary>
            Creates the generator LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.EnsureSignature(System.Type)">
            <summary>
            Fixes up lambda body and parameters to match the signature of the given delegate if needed.
            </summary>
            <param name="delegateType"></param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Validate">
            <summary>
            Validates that the builder has enough information to create the lambda.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Name">
            <summary>
            The name of the lambda.
            Currently anonymous/unnamed lambdas are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ReturnType">
            <summary>
            Return type of the lambda being created.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Locals">
            <summary>
            List of lambda's local variables for direct manipulation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Parameters">
            <summary>
            List of lambda's parameters for direct manipulation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ParamsArray">
            <summary>
            The params array argument, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Body">
            <summary>
            The body of the lambda. This must be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Dictionary">
            <summary>
            The generated lambda should have dictionary of locals
            instead of allocating them directly on the CLR stack.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Global">
            <summary>
            The resulting lambda should be marked as global.
            TODO: remove !!!
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Visible">
            <summary>
            The scope is visible (default). Invisible if false.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.DoNotAddContext">
            <summary>
            Prevents builder from inserting context scope.
            Default is false (will insert if needed).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.MultiRuntimeAwareAttribute">
            <summary>
            marks a field, class, or struct as being safe to have statics which can be accessed
            from multiple runtimes.
            
            Static fields which are not read-only or marked with this attribute will be flagged 
            by a test which looks for state being shared between runtimes.  Before applying this
            attribute you should ensure that it is safe to share the state.  This is typically
            state which is lazy initialized or state which is caching values which are identical
            in all runtimes and are immutable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PerfTrack">
            <summary>
            This class is useful for quickly collecting performance counts for expensive
            operations.  Usually this means operations involving either reflection or
            code gen.  Long-term we need to see if this can be plugged better into the
            standard performance counter architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.PerfTrack.Categories.Temporary">
            <summary>
            temporary categories for quick investigation, use a custom key if you
            need to track multiple items, and if you want to keep it then create 
            a new Categories entry and rename all your temporary entries.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CompilerContext">
            <summary>
            Represents the context that is flowed for doing Compiler.  Languages can derive
            from this class to provide additional contextual information.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._sourceUnit">
            <summary>
            Source unit currently being compiled in the CompilerContext
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._errors">
            <summary>
            Current error sink.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._parserSink">
            <summary>
            Sink for parser callbacks (e.g. brace matching, etc.).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.CompilerContext._options">
            <summary>
            Compiler specific options.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IRestrictedMetaObject">
            <summary>
            Indicates that a MetaObject is already representing a restricted type.  Useful
            when we're already restricted to a known type but this isn't captured in
            the type info (e.g. the type is not sealed).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetLimitType(Microsoft.Scripting.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.LimitType
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetRuntimeType(Microsoft.Scripting.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.RuntimeType
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.Seek(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.SeekRelative(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            A relative displacement with respect to the current position in the token is specified.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.MarkMultiLineTokenEnd">
            <summary>
            Marks token end. Enables to read the current token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.DiscardToken">
            <summary>
            Marks token start. It means the buffer can drop the current token.
            Can be called even if no token has been read yet.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ReadLine">
            <summary>
            Reads till the end of line and returns the character that stopped the reading.
            The returned character is not skipped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ResizeInternal(System.Char[]@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes an array to a speficied new size and copies a portion of the original array into its beginning.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerService.ReadToken">
            <summary>
            Move the tokenizer past the next token and return its category.
            </summary>
            <returns>The token information associated with the token just scanned.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerService.SkipToken">
            <summary>
            Move the tokenizer past the next token.
            </summary>
            <returns><c>False</c> if the end of stream has been reached, <c>true</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerService.ReadTokens(System.Int32)">
            <summary>
            Get all tokens over a block of the stream.
            </summary>
            <remarks>
            <para>
            The scanner should return full tokens. If startLocation + length lands in the middle of a token, the full token
            should be returned.
            </para>
            </remarks>
            <param name="countOfChars">The mininum number of characters to process while getting tokens.</param>
            <returns>A enumeration of tokens.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerService.SkipTokens(System.Int32)">
            <summary>
            Scan from startLocation to at least startLocation + length.
            </summary>
            <param name="countOfChars">The mininum number of characters to process while getting tokens.</param>
            <remarks>
            This method is used to determine state at arbitrary startLocation.
            </remarks>
            <returns><c>False</c> if the end of stream has been reached, <c>true</c> otherwise.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.TokenizerService.CurrentState">
            <summary>
            The current internal state of the scanner.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.TokenizerService.CurrentPosition">
            <summary>
            The current startLocation of the scanner.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.MethodSignatureInfo">
            <summary>
            Helper class to remove methods w/ identical signatures.  Used for GetDefaultMembers
            which returns members from all types in the hierarchy.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.SiteLocalStorage`1">
            <summary>
            Provides storage which is flowed into a callers site.  The same storage object is 
            flowed for multiple calls enabling the callee to cache data that can be re-used
            across multiple calls.
            
            Data is a public field so that this works properly with DynamicSite's as the reference
            type (and EnsureInitialize)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.IConsole">
            <summary>
            Handles input and output for the console. It is comparable to System.IO.TextReader, 
            System.IO.TextWriter, System.Console, etc
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.IConsole.ReadLine(System.Int32)">
            <summary>
            Read a single line of interactive input, or a block of multi-line statements.
            
            An event-driven GUI console can implement this method by creating a thread that
            blocks and waits for an event indicating that input is available
            </summary>
            <param name="autoIndentSize">The indentation level to be used for the current suite of a compound statement.
            The console can ignore this argument if it does not want to support auto-indentation</param>
            <returns>null if the input stream has been closed. A string with a command to execute otherwise.
            It can be a multi-line string which should be processed as block of statements
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHostOptionsParser.Parse(System.String[])">
            <exception cref="T:Microsoft.Scripting.Hosting.Shell.InvalidOptionException"></exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHostOptionsParser.ParseOption(System.String,System.String@,System.String@)">
            <summary>
            name == null means that the argument doesn't specify an option; the value contains the entire argument
            name == "" means that the option name is empty (argument separator); the value is null then
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.Command">
            <summary>
            Literal script command given using -c option
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.FileName">
            <summary>
            Filename to execute passed on the command line options.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.PrintVersionAndExit">
            <summary>
            Only print the version of the script interpreter and exit
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.OptionsParser.Parse(System.String[],Microsoft.Scripting.Hosting.ScriptRuntimeSetup,Microsoft.Scripting.Hosting.LanguageSetup,Microsoft.Scripting.PlatformAdaptationLayer)">
            <exception cref="T:Microsoft.Scripting.Hosting.Shell.InvalidOptionException">On error.</exception>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._input">
            <summary>
            The console input buffer.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._current">
            <summary>
            Current position - index into the input buffer
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._autoIndentSize">
            <summary>
            The number of white-spaces displayed for the auto-indenation of the current line
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._rendered">
            <summary>
            Length of the output currently rendered on screen.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._history">
            <summary>
            Command history
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._options">
            <summary>
            Tab options available in current context
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._cursor">
            <summary>
            Cursort anchor - position of cursor when the routine was called
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._commandLine">
            <summary>
            The command line that this console is attached to.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.SuperConsole.DisplayNextOption(System.ConsoleKeyInfo,System.Boolean)">
            <summary>
            Displays the next option in the option list,
            or beeps if no options available for current input prefix.
            If no input prefix, simply print tab.
            </summary>
            <param name="key"></param>
            <param name="prefix"></param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.SuperConsole.OnEnter(System.Boolean)">
            <summary>
            Handle the enter key. Adds the current input (if not empty) to the history.
            </summary>
            <param name="inputChanged"></param>
            <returns>The input string.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.History">
            <summary>
            Class managing the command history.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.SuperConsoleOptions">
            <summary>
            List of available options
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor">
            <summary>
            Cursor position management
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor._anchorTop">
            <summary>
            Beginning position of the cursor - top coordinate.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor._anchorLeft">
            <summary>
            Beginning position of the cursor - left coordinate.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.CompiledCode">
            <summary>
            Hosting API counterpart for <see cref="P:Microsoft.Scripting.Hosting.CompiledCode.ScriptCode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.CompiledCode.Execute">
            <summary>
            Executes code in a default scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.CompiledCode.Execute(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Execute code within a given scope and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.CompiledCode.Execute``1">
            <summary>
            Executes code in in a default scope and converts to a given type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.CompiledCode.Execute``1(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Execute code within a given scope and converts result to a given type.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.CompiledCode.Engine">
            <summary>
            Engine that compiled this code.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.CompiledCode.DefaultScope">
            <summary>
            Default scope for this code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ErrorListenerProxySink">
            <summary>
            Bridges ErrorSink and ErrorListener. 
            Errors reported by language compilers to ErrorSink are forwarded to the ErrorListener provided by the host.
            </summary>
            <remarks>
            This proxy is created in the scenario when the compiler is processing a single SourceUnit.
            Therefore it could maintain one to one mapping from SourceUnit to ScriptSource.
            In a case, which shouldn't happen, that the compiler reports an error in a different SourceUnit we just create 
            a new instance of the ScriptSource each time. 
            
            TODO: Consider compilation of multiple source units and creating a hashtable mapping SourceUnits to ScriptSources
            within the context of compilation unit.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.ErrorSink.Add(System.String,System.String,System.String,System.String,Microsoft.Scripting.SourceSpan,System.Int32,Microsoft.Scripting.Severity)">
            <summary>
            This overload will be called when a SourceUnit is not available. This can happen if the code is being executed remotely,
            since SourceUnit cannot be marshaled across AppDomains.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.LanguageSetup">
            <summary>
            Stores information needed to setup a language
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.LanguageSetup.#ctor(System.String)">
            <summary>
            Creates a new LanguageSetup
            </summary>
            <param name="typeName">assembly qualified type name of the language
            provider</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.LanguageSetup.#ctor(System.String,System.String)">
            <summary>
            Creates a new LanguageSetup with the provided options
            TODO: remove this overload?
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.LanguageSetup.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new LanguageSetup with the provided options
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.LanguageSetup.GetOption``1(System.String,``0)">
            <summary>
            Gets an option as a strongly typed value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.LanguageSetup.TypeName">
            <summary>
            The assembly qualified type name of the language provider
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.LanguageSetup.DisplayName">
            <summary>
            Display name of the language. If empty, it will be set to the first
            name in the Names list.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.LanguageSetup.Names">
            <remarks>
            Case-insensitive language names.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.LanguageSetup.FileExtensions">
            <remarks>
            Case-insensitive file extension, optionally starts with a dot.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.LanguageSetup.Options">
            <remarks>
            Option names are case-sensitive.
            </remarks>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ObjectOperations">
            <summary>
            ObjectOperations provide a large catalogue of object operations such as member access, conversions, 
            indexing, and things like addition.  There are several introspection and tool support services available
            for more advanced hosts.  
            
            You get ObjectOperation instances from ScriptEngine, and they are bound to their engines for the semantics 
            of the operations.  There is a default instance of ObjectOperations you can share across all uses of the 
            engine.  However, very advanced hosts can create new instances.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.IsCallable(System.Object)">
            <summary>
            Returns true if the object can be called, false if it cannot.  
            
            Even if an object is callable Call may still fail if an incorrect number of arguments or type of arguments are provided.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes the provided object with the given parameters and returns the result.
            
            The prefered way of calling objects is to convert the object to a strongly typed delegate 
            using the ConvertTo methods and then invoking that delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.InvokeMember(System.Object,System.String,System.Object[])">
            <summary>
            Invokes a member on the provided object with the given parameters and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.CreateInstance(System.Object,System.Object[])">
            <summary>
            Creates a new instance from the provided object using the given parameters, and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember(System.Object,System.String)">
            <summary>
            Gets the member name from the object obj.  Throws an exception if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember``1(System.Object,System.String)">
            <summary>
            Gets the member name from the object obj and converts it to the type T.  Throws an exception if the
            member does not exist, is write-only, or cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryGetMember(System.Object,System.String,System.Object@)">
            <summary>
            Gets the member name from the object obj.  Returns true if the member is successfully retrieved and 
            stores the value in the value out param.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ContainsMember(System.Object,System.String)">
            <summary>
            Returns true if the object has a member named name, false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.RemoveMember(System.Object,System.String)">
            <summary>
            Removes the member name from the object obj.  Returns true if the member was successfully removed
            or false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember(System.Object,System.String,System.Object)">
            <summary>
            Sets the member name on object obj to value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember``1(System.Object,System.String,``0)">
            <summary>
            Sets the member name on object obj to value.  This overload can be used to avoid
            boxing and casting of strongly typed members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember(System.Object,System.String,System.Boolean)">
            <summary>
            Gets the member name from the object obj.  Throws an exception if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember``1(System.Object,System.String,System.Boolean)">
            <summary>
            Gets the member name from the object obj and converts it to the type T.  Throws an exception if the
            member does not exist, is write-only, or cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryGetMember(System.Object,System.String,System.Boolean,System.Object@)">
            <summary>
            Gets the member name from the object obj.  Returns true if the member is successfully retrieved and 
            stores the value in the value out param.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ContainsMember(System.Object,System.String,System.Boolean)">
            <summary>
            Returns true if the object has a member named name, false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.RemoveMember(System.Object,System.String,System.Boolean)">
            <summary>
            Removes the member name from the object obj.  Returns true if the member was successfully removed
            or false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Sets the member name on object obj to value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember``1(System.Object,System.String,``0,System.Boolean)">
            <summary>
            Sets the member name on object obj to value.  This overload can be used to avoid
            boxing and casting of strongly typed members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ConvertTo``1(System.Object)">
            <summary>
            Convers the object obj to the type T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ConvertTo(System.Object,System.Type)">
            <summary>
            Converts the object obj to the type type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryConvertTo``1(System.Object,``0@)">
            <summary>
            Converts the object obj to the type T.  Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryConvertTo(System.Object,System.Type,System.Object@)">
            <summary>
            Converts the object obj to the type type.  Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExplicitConvertTo``1(System.Object)">
            <summary>
            Converts the object obj to the type T including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExplicitConvertTo(System.Object,System.Type)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryExplicitConvertTo``1(System.Object,``0@)">
            <summary>
            Converts the object obj to the type T including explicit conversions which may lose information.
            
            Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryExplicitConvertTo(System.Object,System.Type,System.Object@)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.  
            
            Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Linq.Expressions.ExpressionType,System.Object)">
            <summary>
            Performs a generic unary operation on the specified target and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation``2(Microsoft.Linq.Expressions.ExpressionType,``0)">
            <summary>
            Performs a generic unary operation on the strongly typed target and returns the value as the specified type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Linq.Expressions.ExpressionType,System.Object,System.Object)">
            <summary>
            Performs the generic binary operation on the specified targets and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation``3(Microsoft.Linq.Expressions.ExpressionType,``0,``1)">
            <summary>
            Peforms the generic binary operation on the specified strongly typed targets and returns
            the strongly typed result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Add(System.Object,System.Object)">
            <summary>
            Performs addition on the specified targets and returns the result.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Subtract(System.Object,System.Object)">
            <summary>
            Performs subtraction on the specified targets and returns the result.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Power(System.Object,System.Object)">
            <summary>
            Raises the first object to the power of the second object.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Multiply(System.Object,System.Object)">
            <summary>
            Multiplies the two objects.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Divide(System.Object,System.Object)">
            <summary>
            Divides the first object by the second object.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Modulo(System.Object,System.Object)">
            <summary>
            Performs modulus of the 1st object by the second object.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LeftShift(System.Object,System.Object)">
            <summary>
            Shifts the left object left by the right object.  Throws an exception if the
            operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.RightShift(System.Object,System.Object)">
            <summary>
            Shifts the left object right by the right object.  Throws an exception if the
            operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.BitwiseAnd(System.Object,System.Object)">
            <summary>
            Performs a bitwise-and of the two operands.  Throws an exception if the operation 
            cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.BitwiseOr(System.Object,System.Object)">
            <summary>
            Performs a bitwise-or of the two operands.  Throws an exception if the operation 
            cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExclusiveOr(System.Object,System.Object)">
            <summary>
            Performs a exclusive-or of the two operands.  Throws an exception if the operation 
            cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LessThan(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is less than the right object.
            Throws an exception if hte comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GreaterThan(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is greater than the right object.
            Throws an exception if hte comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LessThanOrEqual(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is less than or equal to the right object.
            Throws an exception if hte comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GreaterThanOrEqual(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is greater than or equal to the right object.
            Throws an exception if hte comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Equal(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is equal to the right object.
            Throws an exception if the comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.NotEqual(System.Object,System.Object)">
            <summary>
            Compares the two objects and returns true if the left object is not equal to the right object.
            Throws an exception if hte comparison cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetCodeRepresentation(System.Object)">
            <summary>
            Returns a string which describes the object as it appears in source code
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Format(System.Object)">
            <summary>
            Returns a string representation of the object in a language specific object display format.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMemberNames(System.Object)">
            <summary>
            Returns a list of strings which contain the known members of the object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetDocumentation(System.Object)">
            <summary>
            Returns a string providing documentation for the specified object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetCallSignatures(System.Object)">
            <summary>
            Returns a list of signatures applicable for calling the specified object in a form displayable to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Call(System.Object,System.Object[])">
            <summary>
            Calls the provided object with the given parameters and returns the result.
            
            The prefered way of calling objects is to convert the object to a strongly typed delegate 
            using the ConvertTo methods and then invoking that delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Scripting.Runtime.Operators,System.Object)">
            <summary>
            Performs a generic unary operation on the specified target and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation``2(Microsoft.Scripting.Runtime.Operators,``0)">
            <summary>
            Performs a generic unary operation on the strongly typed target and returns the value as the specified type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Modulus(System.Object,System.Object)">
            <summary>
            Performs modulus of the 1st object by the second object.  Throws an exception
            if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Scripting.Runtime.Operators,System.Object,System.Object)">
            <summary>
            Performs the generic binary operation on the specified targets and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation``3(Microsoft.Scripting.Runtime.Operators,``0,``1)">
            <summary>
            Peforms the generic binary operation on the specified strongly typed targets and returns
            the strongly typed result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Call(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle[])">
            <summary>
            Calls the specified remote object with the specified remote parameters.
            
            Though delegates are preferable for calls they may not always be usable for remote objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Call(System.Runtime.Remoting.ObjectHandle,System.Object[])">
            <summary>
            Calls the specified remote object with the local parameters which will be serialized
            to the remote app domain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Scripting.Runtime.Operators,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs the specified unary operator on the remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Scripting.Runtime.Operators,System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs the specified binary operator on the remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Modulus(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs modulus on the 1st remote object by the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.IsCallable(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Returns true if the remote object is callable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Invoke(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle[])">
            <summary>
            Invokes the specified remote object with the specified remote parameters.
            
            Though delegates are preferable for calls they may not always be usable for remote objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Invoke(System.Runtime.Remoting.ObjectHandle,System.Object[])">
            <summary>
            Invokes the specified remote object with the local parameters which will be serialized
            to the remote app domain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember(System.Runtime.Remoting.ObjectHandle,System.String,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Sets the remote object as a member on the provided remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.SetMember``1(System.Runtime.Remoting.ObjectHandle,System.String,``0)">
            <summary>
            Sets the member name on the remote object obj to value.  This overload can be used to avoid
            boxing and casting of strongly typed members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember(System.Runtime.Remoting.ObjectHandle,System.String)">
            <summary>
            Gets the member name on the remote object.  Throws an exception if the member is not defined or
            is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMember``1(System.Runtime.Remoting.ObjectHandle,System.String)">
            <summary>
            Gets the member name on the remote object.  Throws an exception if the member is not defined or
            is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryGetMember(System.Runtime.Remoting.ObjectHandle,System.String,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Gets the member name on the remote object.  Returns false if the member is not defined or
            is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ContainsMember(System.Runtime.Remoting.ObjectHandle,System.String)">
            <summary>
            Tests to see if the member name is defined on the remote object.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.RemoveMember(System.Runtime.Remoting.ObjectHandle,System.String)">
            <summary>
            Removes the member from the remote object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ConvertTo``1(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Converts the remote object into the specified type returning a handle to
            the new remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ConvertTo(System.Runtime.Remoting.ObjectHandle,System.Type)">
            <summary>
            Converts the remote object into the specified type returning a handle to
            the new remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryConvertTo``1(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Converts the remote object into the specified type returning a handle to
            the new remote object. Returns true if the value can be converted,
            false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryConvertTo(System.Runtime.Remoting.ObjectHandle,System.Type,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Converts the remote object into the specified type returning a handle to
            the new remote object. Returns true if the value can be converted,
            false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExplicitConvertTo``1(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Converts the object obj to the type T including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExplicitConvertTo(System.Runtime.Remoting.ObjectHandle,System.Type)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryExplicitConvertTo``1(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Converts the object obj to the type T including explicit conversions which may lose information.
            
            Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.TryExplicitConvertTo(System.Runtime.Remoting.ObjectHandle,System.Type,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.  
            
            Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Unwrap``1(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Unwraps the remote object and converts it into the specified type before
            returning it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Linq.Expressions.ExpressionType,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs the specified unary operator on the remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.DoOperation(Microsoft.Linq.Expressions.ExpressionType,System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs the specified binary operator on the remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Add(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Adds the two remote objects.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Subtract(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Subtracts the 1st remote object from the second.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Power(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Raises the 1st remote object to the power of the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Multiply(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Multiplies the two remote objects.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Divide(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Divides the 1st remote object by the 2nd. Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Modulo(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs modulus on the 1st remote object by the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>        
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LeftShift(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Shifts the 1st remote object left by the 2nd remote object.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.RightShift(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Shifts the 1st remote  object right by the 2nd remote object.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.BitwiseAnd(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs bitwise-and on the two remote objects.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.BitwiseOr(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs bitwise-or on the two remote objects.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.ExclusiveOr(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Performs exclusive-or on the two remote objects.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LessThan(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is less than the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GreaterThan(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is greater than the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.LessThanOrEqual(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is less than or equal to the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GreaterThanOrEqual(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is greater than or equal to than the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Equal(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is equal to the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.NotEqual(System.Runtime.Remoting.ObjectHandle,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Compares the two remote objects and returns true if the 1st is not equal to the 2nd.  Throws an exception if the operation cannot be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.Format(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Returns a string representation of the object in a langauge specific object display format.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetMemberNames(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Returns a list of strings which contain the known members of the remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetDocumentation(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Returns a string providing documentation for the specified remote object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetCallSignatures(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Returns a list of signatures applicable for calling the specified object in a form displayable to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetLocalObject(System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Helper to unwrap an object - in the future maybe we should validate the current app domain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ObjectOperations.GetLocalObjects(System.Runtime.Remoting.ObjectHandle[])">
            <summary>
            Helper to unwrap multiple objects
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptEngine">
            <summary>
            Represents a language in Hosting API. 
            Hosting API counterpart for <see cref="P:Microsoft.Scripting.Hosting.ScriptEngine.LanguageContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateOperations">
            <summary>
            Returns a new ObjectOperations object.  See the Operations property for why you might want to call this.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateOperations(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Returns a new ObjectOperations object that inherits any semantics particular to the provided ScriptScope.  
            
            See the Operations property for why you might want to call this.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.Execute(System.String)">
            <summary>
            Executes an expression. The execution is not bound to any particular scope.
            </summary>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.Execute(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes an expression within the specified scope.
            </summary>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is a <c>null</c> reference.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scope"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.Execute``1(System.String)">
            <summary>
            Executes an expression within a new scope and converts result to the given type.
            </summary>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.Execute``1(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes an expression within the specified scope and converts result to the given type.
            </summary>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression"/> is a <c>null</c> reference.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scope"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.ExecuteFile(System.String)">
            <summary>
            Executes content of the specified file in a new scope and returns that scope.
            </summary>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.ExecuteFile(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes content of the specified file against the given scope.
            </summary>
            <returns>The <paramref name="scope"/>.</returns>
            <exception cref="T:System.NotSupportedException">The engine doesn't support code execution.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is a <c>null</c> reference.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scope"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.ExecuteAndWrap(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes the expression in the specified scope and return a result.
            Returns an ObjectHandle wrapping the resulting value of running the code.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.ExecuteAndWrap(System.String)">
            <summary>
            Executes the code in an empty scope.
            Returns an ObjectHandle wrapping the resulting value of running the code.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetScope(System.String)">
            <summary>
            This method returns the ScriptScope in which a ScriptSource of given path was executed.  
            
            The ScriptSource.Path property is the key to finding the ScriptScope.  Hosts need 
            to make sure they create a ScriptSource and set its Path property appropriately.
            
            GetScope is primarily useful for tools that need to map files to their execution scopes. For example, 
            an editor and interpreter tool might run a file Foo that imports or requires a file Bar.  
            
            The editor's user might later open the file Bar and want to execute expressions in its context.  
            The tool would need to find Bar's ScriptScope for setting the appropriate context in its interpreter window. 
            This method helps with this scenario.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromString(System.String)">
            <summary>
            Return a ScriptSource object from string contents with the current engine as the language binding.
            
            The default SourceCodeKind is AutoDetect.
            
            The ScriptSource's Path property defaults to <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromString(System.String,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            Return a ScriptSource object from string contents with the current engine as the language binding.
            
            The ScriptSource's Path property defaults to <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromString(System.String,System.String)">
            <summary>
            Return a ScriptSource object from string contents with the current engine as the language binding.
            
            The default SourceCodeKind is AutoDetect.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromString(System.String,System.String,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            Return a ScriptSource object from string contents.  These are helpers for creating ScriptSources' with the right language binding.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromFile(System.String)">
            <summary>
            Return a ScriptSource object from file contents with the current engine as the language binding.  
            
            The path's extension does NOT have to be in ScriptRuntime.GetRegisteredFileExtensions 
            or map to this language engine with ScriptRuntime.GetEngineByFileExtension.
            
            The default SourceCodeKind is File.
            
            The ScriptSource's Path property will be the path argument.
            
            The encoding defaults to System.Text.Encoding.Default.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromFile(System.String,System.Text.Encoding)">
            <summary>
            Return a ScriptSource object from file contents with the current engine as the language binding.  
            
            The path's extension does NOT have to be in ScriptRuntime.GetRegisteredFileExtensions 
            or map to this language engine with ScriptRuntime.GetEngineByFileExtension.
            
            The default SourceCodeKind is File.
            
            The ScriptSource's Path property will be the path argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSourceFromFile(System.String,System.Text.Encoding,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            Return a ScriptSource object from file contents with the current engine as the language binding.  
            
            The path's extension does NOT have to be in ScriptRuntime.GetRegisteredFileExtensions 
            or map to this language engine with ScriptRuntime.GetEngineByFileExtension.
            
            The ScriptSource's Path property will be the path argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(System.CodeDom.CodeObject)">
            <summary>
            This method returns a ScriptSource object from a System.CodeDom.CodeObject.  
            This is a factory method for creating a ScriptSources with this language binding.
            
            The expected CodeDom support is extremely minimal for syntax-independent expression of semantics.  
            
            Languages may do more, but hosts should only expect CodeMemberMethod support, 
            and only sub nodes consisting of the following:
                CodeSnippetStatement
                CodeSnippetExpression
                CodePrimitiveExpression
                CodeMethodInvokeExpression
                CodeExpressionStatement (for holding MethodInvoke)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(System.CodeDom.CodeObject,System.String)">
            <summary>
            This method returns a ScriptSource object from a System.CodeDom.CodeObject.  
            This is a factory method for creating a ScriptSources with this language binding.
            
            The expected CodeDom support is extremely minimal for syntax-independent expression of semantics.  
            
            Languages may do more, but hosts should only expect CodeMemberMethod support, 
            and only sub nodes consisting of the following:
                CodeSnippetStatement
                CodeSnippetExpression
                CodePrimitiveExpression
                CodeMethodInvokeExpression
                CodeExpressionStatement (for holding MethodInvoke)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(System.CodeDom.CodeObject,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            This method returns a ScriptSource object from a System.CodeDom.CodeObject.  
            This is a factory method for creating a ScriptSources with this language binding.
            
            The expected CodeDom support is extremely minimal for syntax-independent expression of semantics.  
            
            Languages may do more, but hosts should only expect CodeMemberMethod support, 
            and only sub nodes consisting of the following:
                CodeSnippetStatement
                CodeSnippetExpression
                CodePrimitiveExpression
                CodeMethodInvokeExpression
                CodeExpressionStatement (for holding MethodInvoke)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(System.CodeDom.CodeObject,System.String,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            This method returns a ScriptSource object from a System.CodeDom.CodeObject.  
            This is a factory method for creating a ScriptSources with this language binding.
            
            The expected CodeDom support is extremely minimal for syntax-independent expression of semantics.  
            
            Languages may do more, but hosts should only expect CodeMemberMethod support, 
            and only sub nodes consisting of the following:
                CodeSnippetStatement
                CodeSnippetExpression
                CodePrimitiveExpression
                CodeMethodInvokeExpression
                CodeExpressionStatement (for holding MethodInvoke)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(Microsoft.Scripting.StreamContentProvider,System.String)">
            <summary>
            These methods return ScriptSource objects from stream contents with the current engine as the language binding.  
            
            The default SourceCodeKind is File.
            
            The encoding defaults to Encoding.Default.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(Microsoft.Scripting.StreamContentProvider,System.String,System.Text.Encoding)">
            <summary>
            These methods return ScriptSource objects from stream contents with the current engine as the language binding.  
            
            The default SourceCodeKind is File.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(Microsoft.Scripting.StreamContentProvider,System.String,System.Text.Encoding,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            These methods return ScriptSource objects from stream contents with the current engine as the language binding.  
            
            The encoding defaults to Encoding.Default.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.CreateScriptSource(Microsoft.Scripting.TextContentProvider,System.String,Microsoft.Scripting.SourceCodeKind)">
            <summary>
            This method returns a ScriptSource with the content provider supplied with the current engine as the language binding.
            
            This helper lets you own the content provider so that you can implement a stream over internal host data structures, such as an editor's text representation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String)">
            <summary>
            Fetches the value of a variable stored in the scope.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), then the name lookup is 
            a literal lookup of the name in the scope's dictionary.  Therefore, it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.RemoveVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String)">
            <summary>
            This method removes the variable name and returns whether 
            the variable was bound in the scope when you called this method.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  If there is a default engine, then the name lookup uses that language's semantics.
            
            Some languages may refuse to remove some variables.  If the scope has a default language that has bound 
            variables that cannot be removed, the language engine throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.SetVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String,System.Object)">
            <summary>
            Assigns a value to a variable in the scope, overwriting any previous value.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.TryGetVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String,System.Object@)">
            <summary>
            Fetches the value of a variable stored in the scope and returns 
            a Boolean indicating success of the lookup.  
            
            When the method's result is false, then it assigns null to value.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetVariable``1(Microsoft.Scripting.Hosting.ScriptScope,System.String)">
            <summary>
            Fetches the value of a variable stored in the scope.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), then the name lookup is 
            a literal lookup of the name in the scope's dictionary.  Therefore, it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            
            Throws an exception if the engine cannot perform the requested type conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.TryGetVariable``1(Microsoft.Scripting.Hosting.ScriptScope,System.String,``0@)">
            <summary>
            Fetches the value of a variable stored in the scope and returns 
            a Boolean indicating success of the lookup.  
            
            When the method's result is false, then it assigns default(T) to value.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            
            Throws an exception if the engine cannot perform the requested type conversion, 
            then it return false and assigns value to default(T).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.ContainsVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String)">
            <summary>
            This method returns whether the variable is bound in this scope.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetVariableHandle(Microsoft.Scripting.Hosting.ScriptScope,System.String)">
            <summary>
            Fetches the value of a variable stored in the scope and returns an the wrapped object as an ObjectHandle.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), then the name lookup is 
            a literal lookup of the name in the scope's dictionary.  Therefore, it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.SetVariable(Microsoft.Scripting.Hosting.ScriptScope,System.String,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Assigns a value to a variable in the scope, overwriting any previous value.
            
            The ObjectHandle value is unwrapped before performing the assignment.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.TryGetVariableHandle(Microsoft.Scripting.Hosting.ScriptScope,System.String,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Fetches the value of a variable stored in the scope and returns 
            a Boolean indicating success of the lookup.  
            
            When the method's result is false, then it assigns null to the value.  Otherwise
            an ObjectHandle wrapping the object is assigned to value.
            
            If there is no engine associated with the scope (see ScriptRuntime.CreateScope), 
            then the name lookup is a literal lookup of the name in the scope's dictionary.  Therefore, 
            it is case-sensitive for example.  
            
            If there is a default engine, then the name lookup uses that language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetService``1(System.Object[])">
            <summary>
            This method returns a language-specific service.  
            
            It provides a point of extensibility for a language implementation 
            to offer more functionality than the standard engine members discussed here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.SetSearchPaths(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Sets the search paths used by the engine for loading files when a script wants 
            to import or require another file of code.  
            </summary>
            <exception cref="T:System.NotSupportedException">The language doesn't allow to set search paths.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptEngine.GetSearchPaths">
            <summary>
            Gets the search paths used by the engine for loading files when a script wants 
            to import or require another file of code.  
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptEngine.Operations">
            <summary>
            Returns a default ObjectOperations for the engine.  
            
            Because an ObjectOperations object caches rules for the types of 
            objects and operations it processes, using the default ObjectOperations for 
            many objects could degrade the caching benefits.  Eventually the cache for 
            some operations could degrade to a point where ObjectOperations stops caching and 
            does a full search for an implementation of the requested operation for the given objects.  
            
            Another reason to create a new ObjectOperations instance is to have it bound
            to the specific view of a ScriptScope.  Languages may attach per-language
            behavior to a ScriptScope which would alter how the operations are performed.
            
            For simple hosting situations, this is sufficient behavior.
            
            
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptEngine.Setup">
            <summary>
            This property returns readon-only LanguageOptions this engine is using.
            </summary>
            <remarks>
            The values are determined during runtime initialization and read-only afterwards. 
            You can change the settings via a configuration file or explicitly using ScriptRuntimeSetup class.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptEngine.Runtime">
            <summary>
            This property returns the ScriptRuntime for the context in which this engine executes.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptEngine.LanguageVersion">
            <summary>
            This property returns the engine's version as a string.  The format is language-dependent.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptHost">
             <summary>
             ScriptHost is collocated with ScriptRuntime in the same app-domain. 
             The host can implement a derived class to consume some notifications and/or 
             customize operations like TryGetSourceUnit,ResolveSourceUnit, etc.
            
             The areguments to the the constructor of the derived class are specified in ScriptRuntimeSetup 
             instance that enters ScriptRuntime initialization.
             
             If the host is remote with respect to DLR (i.e. also with respect to ScriptHost)
             and needs to access objects living in its app-domain it can pass MarshalByRefObject 
             as an argument to its ScriptHost subclass constructor.
             </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.ScriptHost._runtime">
            <summary>
            The runtime the host is attached to.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptHost.RuntimeAttached">
            <summary>
            Invoked after the initialization of the associated Runtime is finished.
            The host can override this method to perform additional initialization of runtime (like loading assemblies etc.).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptHost.EngineCreated(Microsoft.Scripting.Hosting.ScriptEngine)">
            <summary>
            Invoked after a new language is loaded into the Runtime.
            The host can override this method to perform additional initialization of language engines.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptHostProxy">
            <summary>
            Provides hosting to DLR. Forwards DLR requests to the ScriptHost. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider">
            <summary>
            DLR requires any Hosting API provider to implement this class and provide its instance upon Runtime initialization.
            DLR calls on it to perform basic host/system dependent operations.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicRuntimeHostingProvider.PlatformAdaptationLayer">
            <summary>
            Abstracts system operations that are used by DLR and could potentially be platform specific.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptIO">
            <summary>
            Provides host-redirectable IO streams used by DLR languages for default IO.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptIO.SetOutput(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Used if the host stores the output as binary data.
            </summary>
            <param name="stream">Binary stream to write data to.</param>
            <param name="encoding">Encoding used to convert textual data written to the output by the script.</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptIO.SetOutput(System.IO.Stream,System.IO.TextWriter)">
            <summary>
            Used if the host handles both kinds of data (textual and binary) by itself.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptRuntime">
            <summary>
            Represents a Dynamic Language Runtime in Hosting API. 
            Hosting API counterpart for <see cref="T:Microsoft.Scripting.Runtime.ScriptDomainManager"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.#ctor(Microsoft.Scripting.Hosting.ScriptRuntimeSetup)">
            <summary>
            Creates ScriptRuntime in the current app-domain and initialized according to the the specified settings.
            Creates an instance of host class specified in the setup and associates it with the created runtime.
            Both Runtime and ScriptHost are collocated in the current app-domain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.CreateFromConfiguration">
            <summary>
            Creates a new runtime with languages set up according to the current application configuration 
            (using System.Configuration).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.CreateRemote(System.AppDomain,Microsoft.Scripting.Hosting.ScriptRuntimeSetup)">
            <summary>
            Creates ScriptRuntime in the current app-domain and initialized according to the the specified settings.
            Creates an instance of host class specified in the setup and associates it with the created runtime.
            Both Runtime and ScriptHost are collocated in the specified app-domain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.GetEngineByFileExtension(System.String)">
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.GetEngine(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Gets engine for the specified language.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.GetEngineNoLockNoNotification(Microsoft.Scripting.Runtime.LanguageContext,System.Boolean@)">
            <summary>
            Looks up the engine for the specified language. It the engine hasn't been created in this Runtime, it is instantiated here.
            The method doesn't lock nor send notifications to the host.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.ExecuteFile(System.String)">
            <exception cref="T:System.ArgumentException">
            path is empty, contains one or more of the invalid characters defined in GetInvalidPathChars or doesn't have an extension.
            </exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.UseFile(System.String)">
            <exception cref="T:System.ArgumentNullException">path is null</exception>
            <exception cref="T:System.ArgumentException">file extension does not map to language engine</exception>
            <exception cref="T:System.InvalidOperationException">language does not have any search paths</exception>
            <exception cref="T:System.IO.FileNotFoundException">file does exist in language's search path</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntime.LoadAssembly(System.Reflection.Assembly)">
            <summary>
            This method walks the assembly's namespaces and name bindings to ScriptRuntime.Globals 
            to represent the types available in the assembly.  Each top-level namespace name gets 
            bound in Globals to a dynamic object representing the namespace.  Within each top-level 
            namespace object, nested namespace names are bound to dynamic objects representing each 
            tier of nested namespaces.  When this method encounters the same namespace-qualified name, 
            it merges names together objects representing the namespaces.
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntime.Globals">
            <summary>
            This property returns the "global object" or name bindings of the ScriptRuntime as a ScriptScope.  
            
            You can set the globals scope, which you might do if you created a ScriptScope with an 
            IAttributesCollection so that your host could late bind names.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptRuntimeSetup">
            <summary>
            Stores information needed to setup a ScriptRuntime
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.ReadConfiguration">
            <summary>
            Reads setup from .NET configuration system (.config files).
            If there is no configuration available returns an empty setup.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.ReadConfiguration(System.IO.Stream)">
            <summary>
            Reads setup from a specified XML stream.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.ReadConfiguration(System.String)">
            <summary>
            Reads setup from a specified XML file.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.LanguageSetups">
            <summary>
            The list of language setup information for languages to load into
            the runtime
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.DebugMode">
            <summary>
            Indicates that the script runtime is in debug mode.
            This means:
            
            1) Symbols are emitted for debuggable methods (methods associated with SourceUnit).
            2) Debuggable methods are emitted to non-collectable types (this is due to CLR limitations on dynamic method debugging).
            3) JIT optimization is disabled for all methods
            4) Languages may disable optimizations based on this value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.PrivateBinding">
            <summary>
            Ignore CLR visibility checks
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.HostType">
            <summary>
            Can be any derived class of ScriptHost. When set, it allows the
            host to override certain methods to control behavior of the runtime
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.Options">
            <remarks>
            Option names are case-sensitive.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptRuntimeSetup.HostArguments">
            <summary>
            Arguments passed to the host type when it is constructed
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptScope">
             <summary>
             A ScriptScope is a unit of execution for code.  It consists of a global Scope which
             all code executes in.  A ScriptScope can have an arbitrary initializer and arbitrary
             reloader. 
             
             ScriptScope is not thread safe. Host should either lock when multiple threads could 
             access the same module or should make a copy for each thread.
            
             Hosting API counterpart for <see cref="P:Microsoft.Scripting.Hosting.ScriptScope.Scope"/>.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.GetVariable(System.String)">
            <summary>
            Gets a value stored in the scope under the given name.
            </summary>
            <exception cref="T:System.MissingMemberException">The specified name is not defined in the scope.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.GetVariable``1(System.String)">
            <summary>
            Gets a value stored in the scope under the given name.
            Converts the result to the specified type using the conversion that the language associated with the scope defines.
            If no language is associated with the scope, the default CLR conversion is attempted.
            </summary>
            <exception cref="T:System.MissingMemberException">The specified name is not defined in the scope.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.TryGetVariable(System.String,System.Object@)">
            <summary>
            Tries to get a value stored in the scope under the given name.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.TryGetVariable``1(System.String,``0@)">
            <summary>
            Tries to get a value stored in the scope under the given name.
            Converts the result to the specified type using the conversion that the language associated with the scope defines.
            If no language is associated with the scope, the default CLR conversion is attempted.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.SetVariable(System.String,System.Object)">
            <summary>
            Sets the name to the specified value.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.GetVariableHandle(System.String)">
            <summary>
            Gets a handle for a value stored in the scope under the given name.
            </summary>
            <exception cref="T:System.MissingMemberException">The specified name is not defined in the scope.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.TryGetVariableHandle(System.String,System.Runtime.Remoting.ObjectHandle@)">
            <summary>
            Tries to get a handle for a value stored in the scope under the given name.
            Returns <c>true</c> if there is such name, <c>false</c> otherwise. 
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.SetVariable(System.String,System.Runtime.Remoting.ObjectHandle)">
            <summary>
            Sets the name to the specified value.
            </summary>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The value held by the handle isn't from the scope's app-domain and isn't serializable or MarshalByRefObject.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> or <paramref name="handle"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.ContainsVariable(System.String)">
            <summary>
            Determines if this context or any outer scope contains the defined name.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.RemoveVariable(System.String)">
            <summary>
            Removes the variable of the given name from this scope.
            </summary> 
            <returns><c>true</c> if the value existed in the scope before it has been removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is a <c>null</c> reference.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.GetVariableNames">
            <summary>
            Gets a list of variable names stored in the scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptScope.GetItems">
            <summary>
            Gets an array of variable names and their values stored in the scope.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptScope.Engine">
            <summary>
            Gets an engine for the language associated with this scope.
            Returns invariant engine if the scope is language agnostic.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.ScriptSource">
            <summary>
            Hosting counterpart for <see cref="P:Microsoft.Scripting.Hosting.ScriptSource.SourceUnit"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Compile">
            <summary>
            Compile the ScriptSource into CompileCode object that can be executed 
            repeatedly in its default scope or in other scopes without having to recompile the code.
            </summary>
            <exception cref="T:Microsoft.Scripting.SyntaxErrorException">Code cannot be compiled.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Compile(Microsoft.Scripting.Hosting.ErrorListener)">
            <remarks>
            Errors are reported to the specified listener. 
            Returns <c>null</c> if the parser cannot compile the code due to errors.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Compile(Microsoft.Scripting.CompilerOptions)">
            <remarks>
            Errors are reported to the specified listener. 
            Returns <c>null</c> if the parser cannot compile the code due to error(s).
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Compile(Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.Hosting.ErrorListener)">
            <remarks>
            Errors are reported to the specified listener. 
            Returns <c>null</c> if the parser cannot compile the code due to error(s).
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Execute(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes the code in the specified scope.
            Returns an object that is the resulting value of running the code.  
            
            When the ScriptSource is a file or statement, the engine decides what is 
            an appropriate value to return.  Some languages return the value produced 
            by the last expression or statement, but languages that are not expression 
            based may return null.
            </summary>
            <exception cref="T:Microsoft.Scripting.SyntaxErrorException">Code cannot be compiled.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Execute">
            <summary>
            Executes the source code. The execution is not bound to any particular scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Execute``1(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes the code in a specified scope and converts the result to the specified type.
            The conversion is language specific.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.Execute``1">
            <summary>
            Executes the code in an empty scope and converts the result to the specified type.
            The conversion is language specific.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.ExecuteAndWrap(Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Executes the code in the specified scope and return a result.
            Returns an ObjectHandle wrapping the resulting value of running the code.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.ExecuteAndWrap">
            <summary>
            Executes the code in an empty scope.
            Returns an ObjectHandle wrapping the resulting value of running the code.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.ExecuteProgram">
            <summary>
            Runs a specified code as if it was a program launched from OS command shell. 
            and returns a process exit code indicating the success or error condition 
            of executing the code.
            
            Exact behavior depends on the language. Some languages have a dedicated "exit" exception that 
            carries the exit code, in which case the exception is cought and the exit code is returned.
            The default behavior returns the result of program's execution converted to an integer 
            using a language specific conversion.
            </summary>
            <exception cref="T:Microsoft.Scripting.SyntaxErrorException">Code cannot be compiled.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.DetectEncoding">
            <summary>
            Detects the encoding of the content.
            </summary>
            <returns>
            An encoding that is used by the reader of the script source to transcode its content to Unicode text.
            <c>Null</c> if the content is already textual and no transcoding is performed.
            </returns>
            <remarks>
            Note that the default encoding specified when the script source is created could be overridden by 
            an encoding that is found in the content preamble (Unicode BOM or a language specific encoding preamble).
            In that case the preamble encoding is returned. Otherwise, the default encoding is returned.
            </remarks>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.GetCodeLines(System.Int32,System.Int32)">
            <summary>
            Reads specified range of lines (or less) from the source unit. 
            </summary>
            <param name="start">1-based number of the first line to fetch.</param>
            <param name="count">The number of lines to fetch.</param>
            <remarks>
            Which character sequences are considered line separators is language specific.
            If language doesn't specify otherwise "\r", "\n", "\r\n" are recognized line separators.
            </remarks>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.GetCodeLine(System.Int32)">
            <summary>
            Reads a specified line.
            </summary>
            <param name="line">1-based line number.</param>
            <returns>Line content. Line separator is not included.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>
            Which character sequences are considered line separators is language specific.
            If language doesn't specify otherwise "\r", "\n", "\r\n" are recognized line separators.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.ScriptSource.GetCode">
            <summary>
            Gets script source content.
            </summary>
            <returns>Entire content.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <remarks>
            The result includes language specific preambles (e.g. "#coding:UTF-8" encoding preamble recognized by Ruby), 
            but not the preamble defined by the content encoding (e.g. BOM).
            The entire content of the source unit is encoded by single encoding (if it is read from binary stream).
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.ScriptSource.Path">
            <summary>
            Identification of the source unit. Assigned by the host. 
            The format and semantics is host dependent (could be a path on file system or URL).
            <c>null</c> for anonymous script source.
            Cannot be an empty string.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.TokenCategorizer.ReadToken">
            <summary>
            Move the tokenizer past the next token and return its category.
            </summary>
            <returns>The token information associated with the token just scanned.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.TokenCategorizer.SkipToken">
            <summary>
            Move the tokenizer past the next token.
            </summary>
            <returns><c>False</c> if the end of stream has been reached, <c>true</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.TokenCategorizer.ReadTokens(System.Int32)">
            <summary>
            Get all tokens over a block of the stream.
            </summary>
            <remarks>
            <para>
            The scanner should return full tokens. If startLocation + length lands in the middle of a token, the full token
            should be returned.
            </para>
            </remarks>s
            <param name="characterCount">The mininum number of characters to process while getting tokens.</param>
            <returns>A enumeration of tokens.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.TokenCategorizer.SkipTokens(System.Int32)">
            <summary>
            Scan from startLocation to at least startLocation + length.
            </summary>
            <param name="characterCount">The mininum number of characters to process while getting tokens.</param>
            <remarks>
            This method is used to determine state at arbitrary startLocation.
            </remarks>
            <returns><c>False</c> if the end of stream has been reached, <c>true</c> otherwise.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.TokenCategorizer.CurrentState">
            <summary>
            The current internal state of the scanner.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.TokenCategorizer.CurrentPosition">
            <summary>
            The current startLocation of the scanner.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Providers.HostingHelpers">
            <summary>
            Advanced APIs for HAPI providers. These methods should not be used by hosts. 
            They are provided for other hosting API implementers that would like to leverage existing HAPI and 
            extend it with language specific functionality, for example. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Providers.HostingHelpers.CallEngine``2(Microsoft.Scripting.Hosting.ScriptEngine,Microsoft.Func{Microsoft.Scripting.Runtime.LanguageContext,``0,``1},``0)">
            <summary>
            Performs a callback in the ScriptEngine's app domain and returns the result.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpretation.Interpreter">
            <summary>
            Interpreter partial class. This part contains interpretation code for lambdas.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.InterpretLambda(Microsoft.Scripting.Interpretation.InterpreterState,Microsoft.Linq.Expressions.LambdaExpression,System.Object[])">
            <summary>
            Called by the code:LambdaInvoker.Invoke from the delegate generated below by
            code:GetDelegateForInterpreter.
            
            This method must repackage arguments to match the lambdas signature, which
            may mean repackaging the parameter arrays.
            
            Input are two arrays - regular arguments passed into the generated delegate,
            and (if the delegate had params array), the parameter array, separately.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.GetDelegateForInterpreter(Microsoft.Scripting.Interpretation.InterpreterState,Microsoft.Linq.Expressions.LambdaExpression)">
            <summary>
            Gets the delegate associated with the LambdaExpression.
            Either it uses cached MethodInfo and creates delegate from it, or it will generate
            completely new dynamic method, store it in a cache and use it to create the delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.CreateDelegateForInterpreter(System.Type)">
            <summary>
            The core of the interpreter, calling back onto itself via delegates.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.InterpretAndCheckFlow(Microsoft.Scripting.Interpretation.InterpreterState,Microsoft.Linq.Expressions.Expression,System.Object@)">
            <summary>
            Evaluates expression and checks it for ControlFlow. If it is control flow, returns true,
            otherwise returns false.
            </summary>
            <param name="state"></param>
            <param name="node"></param>
            <param name="result">Result of the evaluation</param>
            <returns>true if control flow, false if not</returns>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.InterpretAndCheckYield(Microsoft.Scripting.Interpretation.InterpreterState,Microsoft.Linq.Expressions.Expression,System.Object@)">
            <summary>
            Evaluates an expression and checks to see if the ControlFlow is NextForYield.  If it is then we are currently
            searching for the next yield and we need to execute any additional nodes in a larger compound node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.InterpretLabelExpression(Microsoft.Scripting.Interpretation.InterpreterState,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Labeled statement makes break/continue go to the end of the contained expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpretation.Interpreter.MatchCaller">
            <summary>
            MatchCaller allows to call match maker delegate with the signature (object, CallSite, object[])
            It is used by the call site cache lookup logic when searching for applicable rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.Interpreter.MatchCaller.CreateCaller(System.Type)">
            <summary>
            Uses LCG to create method such as this:
            
            object MatchCaller(object target, CallSite site, object[] args) {
                 return ((ActualDelegateType)target)(site, args[0], args[1], args[2], ...);
            }
            
            inserting appropriate casts and boxings as needed.
            </summary>
            <param name="type">Type of the delegate to call</param>
            <returns>A MatchCallerTarget delegate.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Interpretation.InterpreterState">
            <summary>
            Represents variable storage for one lambda/scope expression in the
            interpreter.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpretation.InterpreterVariables">
            <summary>
            An ILocalVariables implementation for the interpreter
            
            TODO: This isn't quite correct, because it doesn't implement the
            LocalScopeExpression.IsClosure feature that only exposes variables that
            would otherwise be lifted. To implement it correctly would require a
            full variable binding pass, something the interpreter doesn't need
            today. The only thing that this breaks is Python's func_closure
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpretation.LambdaInvoker">
            <summary>
            Helper class used by the interpreter to package lambda as a delegate,
            allow it being called, and then resume interpretation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.LambdaInvoker.TryGetGenericInvokeMethod(System.Int32,System.Reflection.MethodInfo@)">
            <summary>
            Selects an Invoke method declared in this class given the number of parameters.
            Note that the selected overload could only be used if no by-ref parameters are needed in the signature.
            Returns false if there is no overload with that many parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpretation.GeneratorInvoker.Invoke``1(System.Int32@,``0@)">
            <summary>
            Triggers interpretation of the Lambda
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.BigInteger">
            <summary>
            arbitrary precision integers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Create(System.Byte[])">
            <summary>
            Create a BigInteger from a little-endian twos-complement byte array
            (inverse of ToByteArray())
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.GetBits">
            <summary>
            Return the magnitude of this BigInteger as an array of zero or more uints.
            Element zero is the value of the least significant four bytes, element one is
            the value of the four next most significant bytes, etc.
            
            The returned data is the unsigned magnitude of the number. To determine the sign,
            use GetSign().
            
            It is guaranteed that the highest element of the returned array is never zero.
            This means that if the value of this BigInteger is zero, a zero-length array
            is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.makeTwosComplement(System.UInt32[])">
            <summary>
            Do an in-place twos complement of d and also return the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Log">
            <summary>
            Calculates the natural logarithm of the BigInteger.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Log10">
            <summary>
            Calculates log base 10 of a BigInteger.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.ToByteArray">
            <summary>
            Return the value of this BigInteger as a little-endian twos-complement
            byte array, using the fewest number of bytes possible. If the value is zero,
            return an array of one byte whose element is 0x00.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.BigInteger.Sign">
            <summary>
            Return the sign of this BigInteger: -1, 0, or 1.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.Complex64">
            <summary>
            Implementation of the complex number data type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.BinderOps">
            <summary>
            Helper methods that calls are generated to from the default DLR binders.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderOps._dynamicDelegateCache">
            <summary> Table of dynamicly generated delegates which are shared based upon method signature. </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetDelegate(Microsoft.Scripting.Runtime.LanguageContext,System.Object,System.Type)">
            <summary>
            Creates a delegate with a given signature that could be used to invoke this object from non-dynamic code (w/o code context).
            A stub is created that makes appropriate conversions/boxing and calls the object.
            The stub should be executed within a context of this object's language.
            </summary>
            <returns>The delegate or a <c>null</c> reference if the object is not callable.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetCombinedParameters(System.Object[],System.Object)">
            <summary>
            Helper function to combine an object array with a sequence of additional parameters that has been splatted for a function call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Cast">
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Cast.Explicit(System.Object,System.Type)">
            <summary>
            Explicitly casts the object to a given type (and returns it as object)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateInfo">
            <summary>
            Used as the value for the ScriptingRuntimeHelpers.GetDelegate method caching system
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateSignatureInfo">
            <summary>
            Used as the key for the ScriptingRuntimeHelpers.GetDelegate method caching system
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DelegateSignatureInfo.EmitClrCallStub(Microsoft.Scripting.Generation.ILGen)">
            <summary>
            Generates stub to receive the CLR call and then call the dynamic language code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicOperations">
            <summary>
            ObjectOperations provide a large catalogue of object operations such as member access, conversions, 
            indexing, and things like addition.  There are several introspection and tool support services available
            for more advanced hosts.  
            
            You get ObjectOperation instances from ScriptEngine, and they are bound to their engines for the semantics 
            of the operations.  There is a default instance of ObjectOperations you can share across all uses of the 
            engine.  However, very advanced hosts can create new instances.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.CleanupThreshold">
            <summary> the number of sites required before we'll try cleaning up the cache... </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.RemoveThreshold">
            <summary> the minimum difference between the average that is required to remove </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.StopCleanupThreshold">
            <summary> the maximum number we'll remove on a single cache cleanup </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.ClearThreshold">
            <summary> the number of sites we should clear after if we can't make progress cleaning up otherwise </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations._sites">
            <summary> a dictionary of SiteKey's which are used to cache frequently used operations, logically a set </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.LastCleanup">
            <summary> the # of sites we had created at the last cleanup </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.DynamicOperations.SitesCreated">
            <summary> the total number of sites we've ever created </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.Invoke(System.Object,System.Object[])">
            <summary>
            Calls the provided object with the given parameters and returns the result.
            
            The prefered way of calling objects is to convert the object to a strongly typed delegate 
            using the ConvertTo methods and then invoking that delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.InvokeMember(System.Object,System.String,System.Object[])">
            <summary>
            Invokes a member on the provided object with the given parameters and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.InvokeMember(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Invokes a member on the provided object with the given parameters and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.CreateInstance(System.Object,System.Object[])">
            <summary>
            Creates a new instance from the provided object using the given parameters, and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetMember(System.Object,System.String)">
            <summary>
            Gets the member name from the object obj.  Throws an exception if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetMember``1(System.Object,System.String)">
            <summary>
            Gets the member name from the object obj and converts it to the type T.  Throws an exception if the
            member does not exist, is write-only, or cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryGetMember(System.Object,System.String,System.Object@)">
            <summary>
            Gets the member name from the object obj.  Returns true if the member is successfully retrieved and 
            stores the value in the value out param.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ContainsMember(System.Object,System.String)">
            <summary>
            Returns true if the object has a member named name, false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.RemoveMember(System.Object,System.String)">
            <summary>
            Removes the member name from the object obj.  Returns true if the member was successfully removed
            or false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.SetMember(System.Object,System.String,System.Object)">
            <summary>
            Sets the member name on object obj to value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.SetMember``1(System.Object,System.String,``0)">
            <summary>
            Sets the member name on object obj to value.  This overload can be used to avoid
            boxing and casting of strongly typed members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetMember(System.Object,System.String,System.Boolean)">
            <summary>
            Gets the member name from the object obj.  Throws an exception if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetMember``1(System.Object,System.String,System.Boolean)">
            <summary>
            Gets the member name from the object obj and converts it to the type T.  Throws an exception if the
            member does not exist, is write-only, or cannot be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryGetMember(System.Object,System.String,System.Boolean,System.Object@)">
            <summary>
            Gets the member name from the object obj.  Returns true if the member is successfully retrieved and 
            stores the value in the value out param.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ContainsMember(System.Object,System.String,System.Boolean)">
            <summary>
            Returns true if the object has a member named name, false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.RemoveMember(System.Object,System.String,System.Boolean)">
            <summary>
            Removes the member name from the object obj.  Returns true if the member was successfully removed
            or false if the member does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.SetMember(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Sets the member name on object obj to value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.SetMember``1(System.Object,System.String,``0,System.Boolean)">
            <summary>
            Sets the member name on object obj to value.  This overload can be used to avoid
            boxing and casting of strongly typed members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ConvertTo``1(System.Object)">
            <summary>
            Convers the object obj to the type T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ConvertTo(System.Object,System.Type)">
            <summary>
            Converts the object obj to the type type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryConvertTo``1(System.Object,``0@)">
            <summary>
            Converts the object obj to the type T.  Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryConvertTo(System.Object,System.Type,System.Object@)">
            <summary>
            Converts the object obj to the type type.  Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ExplicitConvertTo``1(System.Object)">
            <summary>
            Convers the object obj to the type T including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.ExplicitConvertTo(System.Object,System.Type)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryExplicitConvertTo(System.Object,System.Type,System.Object@)">
            <summary>
            Converts the object obj to the type type including explicit conversions which may lose information.  
            
            Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.TryExplicitConvertTo``1(System.Object,``0@)">
            <summary>
            Converts the object obj to the type T.  Returns true if the value can be converted, false if it cannot.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation``2(Microsoft.Linq.Expressions.ExpressionType,``0)">
            <summary>
            Performs a generic unary operation on the strongly typed target and returns the value as the specified type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation``3(Microsoft.Linq.Expressions.ExpressionType,``0,``1)">
            <summary>
            Peforms the generic binary operation on the specified strongly typed targets and returns
            the strongly typed result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation(System.String,System.Object)">
            <summary>
            Performs a generic unary operation on the specified target and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation``2(System.String,``0)">
            <summary>
            Performs a generic unary operation on the strongly typed target and returns the value as the specified type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation(Microsoft.Scripting.Runtime.Operators,System.Object,System.Object)">
            <summary>
            Performs the generic binary operation on the specified targets and returns the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.DoOperation``3(System.String,``0,``1)">
            <summary>
            Peforms the generic binary operation on the specified strongly typed targets and returns
            the strongly typed result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetMemberNames(System.Object)">
            <summary>
            Returns a list of strings which contain the known members of the object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.Format(System.Object)">
            <summary>
            Returns a string representation of the object in a language specific object display format.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetOrCreateSite``2(Microsoft.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Gets or creates a dynamic site w/ the specified type parameters for the provided binder.
            </summary>
            <remarks>
            This will either get the site from the cache or create a new site and return it. The cache
            may be cleaned if it's gotten too big since the last usage.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetOrCreateSite``3(Microsoft.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Gets or creates a dynamic site w/ the specified type parameters for the provided binder.
            </summary>
            <remarks>
            This will either get the site from the cache or create a new site and return it. The cache
            may be cleaned if it's gotten too big since the last usage.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetOrCreateSite``4(Microsoft.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Gets or creates a dynamic site w/ the specified type parameters for the provided binder.
            </summary>
            <remarks>
            This will either get the site from the cache or create a new site and return it. The cache
            may be cleaned if it's gotten too big since the last usage.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetOrCreateSite``1(Microsoft.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Gets or creates a dynamic site w/ the specified type parameters for the provided binder.
            </summary>
            <remarks>
            This will either get the site from the cache or create a new site and return it. The cache
            may be cleaned if it's gotten too big since the last usage.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.GetOrCreateSite``1(Microsoft.Runtime.CompilerServices.CallSiteBinder,Microsoft.Func{Microsoft.Runtime.CompilerServices.CallSiteBinder,``0})">
            <summary>
            Helper to create to get or create the dynamic site - called by the GetSite methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicOperations.CleanupNoLock">
            <summary>
            Removes items from the cache that have the lowest usage...
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicOperations.SiteKey">
            <summary>
            Helper class for tracking all of our unique dynamic sites and their
            usage patterns.  We hash on the combination of the binder and site type.
            
            We also track the hit count and the key holds the site associated w/ the 
            key.  Logically this is a set based upon the binder and site-type but we
            store it in a dictionary.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ISlice">
            <summary>
            A useful interface for taking slices of numeric arrays, inspired by Python's Slice objects.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Start">
            <summary>
            The starting index of the slice or null if no first index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Stop">
            <summary>
            The ending index of the slice or null if no ending index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Step">
            <summary>
            The length of step to take
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetObject(System.Int64)">
            <summary>
            Given an ID returns the object associated with that ID.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetId(System.Object)">
            <summary>
            Gets a unique ID for an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.Cleanup">
            <summary>
            Goes over the hashtable and removes empty entries 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.Wrapper">
            <summary>
            Weak-ref wrapper caches the weak reference, our hash code, and the object ID.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.WrapperComparer">
            <summary>
            WrapperComparer treats Wrapper as transparent envelope 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.InvariantContext">
            <summary>
            Singleton LanguageContext which represents a language-neutral LanguageContext
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageContext">
            <summary>
            Provides language specific facilities which are typicalled called by the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetSourceReader(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Provides a text reader for source code that is to be read from a given stream.
            </summary>
            <param name="stream">The stream open for reading. The stream must also allow seeking.</param>
            <param name="defaultEncoding">An encoding that should be used if the stream doesn't have Unicode or language specific preamble.</param>
            <returns>The reader.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetCompilerOptions">
            <summary>
            Creates the language specific CompilerOptions object for compilation of code not bound to any particular scope.
            The language should flow any relevant options from LanguageContext to the newly created options instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetCompilerOptions(Microsoft.Scripting.Runtime.Scope)">
            <summary>
            Creates the language specific CompilerOptions object for compilation of code bound to a given scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.CompileSourceCode(Microsoft.Scripting.SourceUnit,Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.ErrorSink)">
            <summary>
            Parses the source code within a specified compiler context. 
            The source unit to parse is held on by the context.
            </summary>
            <returns><b>null</b> on failure.</returns>
            <remarks>Could also set the code properties and line/file mappings on the source unit.</remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.TryLookupName(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Looks up the name in the provided Scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.LookupName(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.SymbolId)">
            <summary>
            Looks up the name in the provided scope using the current language's semantics.
            
            If the name cannot be found throws the language appropriate exception or returns
            the language's appropriate default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.SetName(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Attempts to set the name in the provided scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.RemoveName(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to remove the name from the provided scope using the current language's semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.TryLookupGlobal(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attemps to lookup a global variable using the language's semantics called from
            the provided Scope.  The default implementation will attempt to lookup the variable
            at the host level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.MissingName(Microsoft.Scripting.SymbolId)">
            <summary>
            Called when a lookup has failed and an exception should be thrown.  Enables the 
            language context to throw the appropriate exception for their language when
            name lookup fails.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetModuleCache(Microsoft.Scripting.SymbolId)">
            <summary>
            Returns a ModuleGlobalCache for the given name.  
            
            This cache enables fast access to global values when a SymbolId is not defined after searching the Scope's.  Usually
            a language implements lookup of the global value via TryLookupGlobal.  When GetModuleCache returns a ModuleGlobalCache
            a cached value can be used instead of calling TryLookupGlobal avoiding a possibly more expensive lookup from the 
            LanguageContext.  The ModuleGlobalCache can be held onto and have its value updated when the cache is invalidated.
            
            By default this returns a cache which indicates no caching should occur and the LanguageContext will be 
            consulted when a module value is not available. If a LanguageContext only caches some values it can return 
            the value from the base method when the value should not be cached.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.InterpretExceptionThrow(Microsoft.Scripting.Interpretation.InterpreterState,System.Exception,System.Boolean)">
            <summary>
            Called by an interpreter when an exception is about to be thrown by an interpreted or
            when a CLR method is called that threw an exception.
            </summary>
            <param name="state">
            The current interpreted frame state. The frame is either throwing the exception or 
            is the interpreted frame that is calling a CLR method that threw or propagated the exception. 
            </param>
            <param name="exception">The exception to be (re)thrown.</param>
            <param name="isInterpretedThrow">Whether the exception is thrown by an interpreted code.</param>
            <remarks>
            The method can be called multiple times for a single exception if the interpreted code calls some CLR code that
            calls an interpreted code that throws an exception. The method is called at each interpeted/non-interpreted frame boundary
            and in the frame that raised the exception.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.GetMemberNames(System.Object)">
            <summary>
            Gets the member names associated with the object
            By default, only returns IDO names
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageContext.FormatObject(Microsoft.Scripting.Runtime.DynamicOperations,System.Object)">
            <summary>
            Returns a string representation of the object in a language specific object display format.
            </summary>
            <param name="operations">Dynamic sites container that could be used for any dynamic dispatches necessary for formatting.</param>
            <param name="obj">Object to format.</param>
            <returns>A string representation of object.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.ContextId">
            <summary>
            Provides the ContextId which includes members that should only be shown for this LanguageContext.
            
            ContextId's are used for filtering by Scope's.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.DomainManager">
            <summary>
            Gets the ScriptDomainManager that this LanguageContext is running within.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.LanguageContext.CanCreateSourceCode">
            <summary>
            Whether the language can parse code and create source units.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider">
            <summary>
            Internal class which binds a LanguageContext, StreamContentProvider, and Encoding together to produce
            a TextContentProvider which reads binary data with the correct language semantics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.TextContentProvider">
            <summary>
            Provides a factory to create TextReader's over one source of textual content.
            
            TextContentProvider's are used when reading from a source which is already decoded
            or has a known specific decoding.  
            
            For example a text editor might provide a TextContentProvider whose backing is
            an in-memory text buffer that the user can actively edit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.TextContentProvider.GetReader">
            <summary>
            Creates a new TextReader which is backed by the content the TextContentProvider was created for.
            
            This method may be called multiple times.  For example once to compile the code and again to get
            the source code to display error messages.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LocalsDictionary">
            <summary>
            Creates a dictionary of locals in this scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CustomSymbolDictionary">
            <summary>
            Abstract base class used for optimized thread-safe SymbolDictionaries. 
            
            Implementers derive from this class and override the GetExtraKeys, TrySetExtraValue, 
            and TryGetExtraValue methods. When looking up a value first the extra keys will be 
            searched using the optimized Try*ExtraValue functions.  If the value isn't found there
            then the value is stored in the underlying .NET dictionary.
            
            Implementors can optionally override the object key functionality to store object keys
            using their own mechanism.  By default object keys are stored in their own dictionary
            which is stored in the primary SymbolId dictionary under an invalid symbol id.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.BaseSymbolDictionary">
            <summary>
            Base class for SymbolId dictionaries.  
            
            SymbolId dictionaries are fast dictionaries used for looking up members of classes, 
            function environments, function locals, and other places which are typically indexed by 
            string names.  
            
            SymbolId dictionaries support both keying by SymbolId (the common case) and object keys 
            (supporting late bound access to the dictionary as a normal Dictionary&lt;object, object&gt; 
            when exposed directly to user code).  When indexed by objects null is a valid value for the
            key.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.IValueEquality">
            <summary>
            Provides hashing and equality based upon the value of the object instead of the reference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.IValueEquality.GetValueHashCode">
            <summary>
            Gets the hash code for the value of the instance.
            </summary>
            <returns>A hash code</returns>
            <exception cref="T:Microsoft.Scripting.ArgumentTypeException">The type is mutable and cannot be hashed by value</exception>
        </member>
        <member name="M:Microsoft.Scripting.IValueEquality.ValueEquals(System.Object)">
            <summary>
            Determines if two values are equal
            </summary>
            <param name="other">The object to compare the current object against.</param>
            <returns>Returns true if the objects are equal, false if they are not.</returns>        
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BaseSymbolDictionary.#ctor">
            <summary>
            Creates a new SymbolIdDictBase from the specified creating context which will be
            used for comparisons.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.IAttributesCollection">
            <summary>
            This interface represents a dictionary that can be accessed using symbols and also arbitrary objects.
            This should conceptually inherit from IDictionary&lt;object, object&gt;, but we do not do that as we want the default indexer
            property to be indexed by SymbolId, not by object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.IAttributesCollection.Add(Microsoft.Scripting.SymbolId,System.Object)">
            
             Access using SymbolId keys
            
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetExtraKeys">
            <summary>
            Gets a list of the extra keys that are cached by the the optimized implementation
            of the module.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TrySetExtraValue(Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Try to set the extra value and return true if the specified key was found in the 
            list of extra values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TryGetExtraValue(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Try to get the extra value and returns true if the specified key was found in the
            list of extra values.  Returns true even if the value is Uninitialized.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeysDictionary">
            <summary>
            Field dictionaries are usually indexed using literal strings, which is handled using the Symbols.
            However, Python does allow non-string keys too. We handle this case by lazily creating an object-keyed dictionary,
            and keeping it in the symbol-indexed dictionary. Such access is slower, which is acceptable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeys(System.Collections.Generic.List{System.Object})">
            <summary>
            Appends the object keys to the provided list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectValues(System.Collections.Generic.List{System.Object})">
            <summary>
            Appends the values stored under object keys to the provided list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectKeyCount">
            <summary>
            Gets the count of object keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.GetObjectItems">
            <summary>
            Gets an IDictionaryEnumerator for all of the object key/value pairs.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.AddObjectKey(System.Object,System.Object)">
            <summary>
            Stores the specified value under the specified object key.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.RemoveObjectKey(System.Object)">
            <summary>
            Removes the specified object key from the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomSymbolDictionary.TryGetObjectValue(System.Object,System.Object@)">
            <summary>
            Attemps to get the value stored under the specified object key.
            
            Returns true if the key was found, false if not found.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ParamDictionaryAttribute">
            <summary>
            This attribute is the dictionary equivalent of the System.ParamArrayAttribute.
            It is used to mark a parameter that can accept an arbitrary dictionary of
            name/value pairs for a method called with named arguments.  This parameter
            must be applied to a type that implements IDictionary(string, object) or
            IDictionary(SymbolId, object).
            
            For eg. in this Python method,
                def foo(**paramDict): print paramDict
                foo(a=1, b=2)
            paramDict will be {"a":1, "b":2}
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PositionTrackingWriter">
            <summary>
            Efficiently tracks (line,column) information as text is added, and
            collects line mappings between the original and generated source code
            so we can generate correct debugging information later
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.PositionTrackingWriter.MapLocation(System.CodeDom.CodeLinePragma)">
            <summary>
            Marks the current position of the writer as corresponding to the
            original location passed in
            </summary>
            <param name="linePragma">the line pragma corresponding to the 
            current position in the generated code</param>
        </member>
        <member name="T:Microsoft.Scripting.StreamContentProvider">
            <summary>
            Provides a factory to create streams over one source of binary content.  
            
            StreamContentProvider's are used when opening a file of an unknown encoding.  The
            StreamContentProvider will be wrapped in a TextContentProvider provided by the language
            which can support a language specific way of interpreting the binary data into text. 
            
            For example some languages allow a marker at the beginning of the file which specifies
            the encoding of the rest of the file.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.StreamContentProvider.GetStream">
            <summary>
            Creates a new Stream which is backed by the content the StreamContentProvider was created for.
            
            For example if the StreamContentProvider was backing a file then GetStream re-opens the file and returns
            the new stream.
            
            This method may be called multiple times.  For example once to compile the code and again to get
            the source code to display error messages.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.TokenTriggers">
            <summary>
            See also <c>Microsoft.VisualStudio.Package.TokenTriggers</c>.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceLocation">
            <summary>
            Represents a location in source code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new source location.
            </summary>
            <param name="index">The index in the source stream the location represents (0-based).</param>
            <param name="line">The line in the source stream the location represents (1-based).</param>
            <param name="column">The column in the source stream the location represents (1-based).</param>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Equality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Inequality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are not equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are not the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.Compare(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>0 if the locations are equal, -1 if the left one is less than the right one, 1 otherwise.</returns>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.None">
            <summary>
            A location that is valid but represents no location at all.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.Invalid">
            <summary>
            An invalid location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.MinValue">
            <summary>
            A minimal valid location.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Index">
            <summary>
            The index in the source stream the location represents (0-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Line">
            <summary>
            The line in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Column">
            <summary>
            The column in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.IsValid">
            <summary>
            Whether the location is a valid location.
            </summary>
            <returns>True if the location is valid, False otherwise.</returns>
        </member>
        <member name="T:Microsoft.Scripting.SourceSpan">
            <summary>
            Stores the location of a span of text in a source file.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.#ctor(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Constructs a new span with a specific start and end location.
            </summary>
            <param name="start">The beginning of the span.</param>
            <param name="end">The end of the span.</param>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.None">
            <summary>
            A valid span that represents no location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.Invalid">
            <summary>
            An invalid span.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Equality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Inequality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are not equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are not the same, False otherwise.</returns>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Start">
            <summary>
            The start location of the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.End">
            <summary>
            The end location of the span. Location of the first character behind the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Length">
            <summary>
            Length of the span (number of characters inside the span).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.IsValid">
            <summary>
            Whether the locations in the span are valid.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary-like object used for caches.
            </summary>
            <param name="maxSize">The maximum number of elements to store.</param>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with 'key', returning true if it's found and
            false if it's not present.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.Add(`0,`1)">
            <summary>
            Adds a new element to the cache, replacing and moving it to the front if the
            element is already present.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.CacheDict`2.Item(`0)">
            <summary>
            Returns the value associated with the given key, or throws KeyNotFoundException
            if the key is not present.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CopyOnWriteList`1">
            <summary>
            List optimized for few writes and multiple reads. It provides thread-safe read and write access. 
            Iteration is not thread-safe by default, but GetCopyForRead allows for iteration 
            without taking a lock.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CopyOnWriteList`1.GetCopyForRead">
            <summary>
            Gets a copy of the contents of the list. The copy will not change even if the original
            CopyOnWriteList object is modified. This method should be used to iterate the list in
            a thread-safe way if no lock is taken. Iterating on the original list is not guaranteed 
            to be thread-safe.
            </summary>
            <returns>The returned copy should not be modified by the caller.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.GetExpressions(Microsoft.Scripting.DynamicMetaObject[])">
            <summary>
            Returns the list of expressions represented by the <see cref="T:Microsoft.Scripting.DynamicMetaObject"/> instances.
            </summary>
            <param name="objects">An array of <see cref="T:Microsoft.Scripting.DynamicMetaObject"/> instances to extract expressions from.</param>
            <returns>The array of expressions.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.ObjectToMetaObject(System.Object,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.Scripting.DynamicMetaObject"/> for a runtime value and the expression that represents it during the binding process.
            </summary>
            <param name="argValue">The runtime value to be represented by the <see cref="T:Microsoft.Scripting.DynamicMetaObject"/>.</param>
            <param name="parameterExpression">An expression to represent this <see cref="T:Microsoft.Scripting.DynamicMetaObject"/> during the binding process.</param>
            <returns>The new instance of <see cref="T:Microsoft.Scripting.DynamicMetaObject"/>.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double)">
            <summary>
            Behaves like Math.Round(value, MidpointRounding.AwayFromZero)
            Needed because CoreCLR doesn't support this particular overload of Math.Round
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double,System.Int32)">
            <summary>
            Behaves like Math.Round(value, precision, MidpointRounding.AwayFromZero)
            However, it works correctly on negative precisions and cases where precision is
            outside of the [-15, 15] range.
            
            (This function is also needed because CoreCLR lacks this overload.)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2">
            <summary>
            Thread safe dictionary that allows lazy-creation where readers will block for
            the creation of the lazily created value.  Call GetOrCreateValue w/ a key
            and a callback function.  If the value exists it is returned, if not the create
            callback is called (w/o any locks held).  The create call back will only be called
            once for each key.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2.PublishInfo`1">
            <summary>
            Helper class which stores the published value
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectedCaller.FastCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Fast creation works if we have a known primitive types for the entire
            method siganture.  If we have any non-primitive types then FastCreate
            falls back to SlowCreate which works for all types.
            
            Fast creation is fast because it avoids using reflection (MakeGenericType
            and Activator.CreateInstance) to create the types.  It does this through
            calling a series of generic methods picking up each strong type of the
            signature along the way.  When it runs out of types it news up the 
            appropriate ReflectedCaller with the strong-types that have been built up.
            
            One relaxation is that for return types which are non-primitive types
            we can fallback to object due to relaxed delegates.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectedCaller.Create(System.Reflection.MethodInfo)">
            <summary>
            Creates a new ReflectedCaller which can be used to quickly invoke the provided MethodInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectedCaller.TryGetParameterOrReturnType(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[],System.Int32)">
            <summary>
            Gets the next type or null if no more types are available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectedCaller.SlowCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Uses reflection to create new instance of the appropriate ReflectedCaller
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Set`1">
            <summary>
            A simple hashset, built on Dictionary{K, V}
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1">
            <summary>
            Provides fast strongly typed thread local storage.  This is significantly faster than
            Thread.GetData/SetData.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetOrCreate(Microsoft.Func{`0})">
            <summary>
            Gets the current value if its not == null or calls the provided function
            to create a new value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.Update(Microsoft.Func{`0,`0})">
            <summary>
            Calls the provided update function with the current value and
            replaces the current value with the result of the function.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetStorageInfo">
            <summary>
            Gets the StorageInfo for the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.RetryOrCreateStorageInfo(Microsoft.Scripting.Utils.ThreadLocal{`0}.StorageInfo[])">
            <summary>
            Called when the fast path storage lookup fails. if we encountered the Empty storage 
            during the initial fast check then spin until we hit non-empty storage and try the fast 
            path again.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.CreateStorageInfo">
            <summary>
            Creates the StorageInfo for the thread when one isn't already present.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value for the current thread.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1.StorageInfo">
            <summary>
            Helper class for storing the value.  We need to track if a ManagedThreadId
            has been re-used so we also store the thread which owns the value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsSealedOrValueType(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            
            TODO: this should not be needed. Type.IsSealed does the right thing.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ValueArray`1">
            <summary>
            Represents an array that has value equality.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakCollection`1">
            <summary>
            Simple class for tracking a list of items and enumerating over them.
            The items are stored in weak references; if the objects are collected,
            they will not be seen when enumerating.
            </summary>
            <typeparam name="T">The type of the collection element.</typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakDictionary`2">
            <summary>
            Similar to Dictionary[TKey,TValue], but it also ensures that the keys will not be kept alive
            if the only reference is from this collection. The value will be kept alive as long as the key
            is alive.
            
            This currently has a limitation that the caller is responsible for ensuring that an object used as 
            a key is not also used as a value in *any* instance of a WeakHash. Otherwise, it will result in the
            object being kept alive forever. This effectively means that the owner of the WeakHash should be the
            only one who has access to the object used as a value.
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.WeakDictionary`2.CheckCleanup">
            <summary>
            Check if any of the keys have gotten collected
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DebugOptions">
            <summary>
            This class holds onto internal debugging options used in this assembly. 
            These options can be set via environment variables DLR_{option-name}.
            Boolean options map "true" to true and other values to false.
            
            These options are for internal debugging only, and should not be
            exposed through any public APIs.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.LightweightScopes">
            <summary>
            Generate optimized scopes that can be garbage collected
            (globals are stored in an array instead of static fields on a
            generated type)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.GetTupleType(System.Int32)">
            <summary>
            Gets the unbound generic Tuple type which has at lease size slots or null if a large enough tuple is not available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.MakeTupleType(System.Type[])">
            <summary>
            Creates a generic tuple with the specified types.  
            
            If the number of slots fits within the maximum tuple size then we simply 
            create a single tuple.  If it's greater then we create nested tuples 
            (e.g. a Tuple`2 which contains a Tuple`128 and a Tuple`8 if we had a size of 136).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.GetSize(System.Type)">
            <summary>
            Gets the number of usable slots in the provided Tuple type including slots available in nested tuples.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.MakeTuple(System.Type,System.Object[])">
            <summary>
            Creates a new instance of tupleType with the specified args.  If the tuple is a nested
            tuple the values are added in their nested forms.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.GetTupleValues(Microsoft.Scripting.Tuple)">
            <summary>
            Gets the values from a tuple including unpacking nested values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.GetAccessPath(System.Type,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Tuple.GetAccessProperties(System.Type,System.Int32,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IExpressionSerializable">
            <summary>
            Enables an object to be serializable to an Expression tree.  The expression tree can then
            be emitted into an assembly enabling the de-serialization of the object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConversionResultKind">
            <summary>
            Determines the result of a conversion action.  The result can either result in an exception, a value that
            has been successfully converted or default(T), or a true/false result indicating if the value can be converted.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitCast">
            <summary>
            Attempts to perform available implicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitCast">
            <summary>
            Attempst to perform available implicit and explicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitTry">
            <summary>
            Attempts to perform available implicit conversions and returns default(ReturnType) if no conversions can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ImplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitTry">
            <summary>
            Attempts to perform available implicit and explicit conversions and returns default(ReturnType) if no conversions 
            can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ExplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.None">
            <summary>
            No member binding flags
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.Bound">
            <summary>
            The result of the get should produce a value that is bound to the instance it was extracted from, if possible.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.GetMemberBindingFlags.NoThrow">
            <summary>
            Instead of throwing the binder will return OperationFailed.Value if the member does not exist or is write-only.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Argument">
            <summary>
            TODO: Alternatively, it should be sufficient to remember indices for this, list, dict and block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ArgumentType">
            <summary>
            Convention for an individual argument at a callsite.
            
            Multiple different callsites can match against a single declaration. 
            Some argument kinds can be "unrolled" into multiple arguments, such as list and dictionary. 
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Simple">
            <summary>
            Simple unnamed positional argument.
            In Python: foo(1,2,3) are all simple arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Named">
            <summary>
            Argument with associated name at the callsite
            In Python: foo(a=1)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.List">
            <summary>
            Argument containing a list of arguments. 
            In Python: foo(*(1,2*2,3))  would match 'def foo(a,b,c)' with 3 declared arguments such that (a,b,c)=(1,4,3).
                 it could also match 'def foo(*l)' with 1 declared argument such that l=(1,4,3)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Dictionary">
            <summary>
            Argument containing a dictionary of named arguments.
            In Python: foo(**{'a':1, 'b':2})
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker">
            <summary>
            Represents a logical member of a type.  The member could either be real concrete member on a type or
            an extension member.
            
            This seperates the "physical" members that .NET knows exist on types from the members that
            logically exist on a type.  It also provides other abstractions above the level of .NET reflection
            such as MemberGroups and NamespaceTracker's.
            
            It also provides a wrapper around the reflection APIs which cannot be extended from partial trust.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetValue(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Gets the expression that creates the value.  
            
            Returns null if it's an error to get the value.  The caller can then call GetErrorForGet to get 
            the correct error Expression (or null if they should provide a default).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.Call(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ActionBinder,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Gets an expression that performs a call on the object using the specified arguments.
            
            Returns null if it's an error to perform the specific operation.  The caller can then call 
            GetErrorsForDoCall to get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetError(Microsoft.Scripting.Actions.ActionBinder)">
            <summary>
            Returns the error associated with getting the value.  
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundError(Microsoft.Scripting.Actions.ActionBinder,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Returns the error associated with accessing this member via a bound instance.
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundValue(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Helper for getting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ActionBinder,System.Type,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.BindToInstance(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Binds the member tracker to the specified instance rturning a new member tracker if binding 
            is possible.  If binding is not possible the existing member tracker will be returned.  For example
            binding to a static field results in returning the original MemberTracker.  Binding to an instance
            field results in a new BoundMemberTracker which will get GetBoundValue/SetBoundValue to pass the
            instance through.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.MemberType">
            <summary>
            The type of member tracker.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.DeclaringType">
            <summary>
            The logical declaring type of the member.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.Name">
            <summary>
            The name of the member.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker.MemberKey">
            <summary>
            We ensure we only produce one MemberTracker for each member which logically lives on the declaring type.  So 
            for example if you get a member from a derived class which is declared on the base class it should be the same 
            as getting the member from the base class.  That�s easy enough until you get into extension members � here there
            might be one extension member which is being applied to multiple types.  Therefore we need to take into account the 
            extension type when ensuring that we only have 1 MemberTracker ever created.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSignature">
            <summary>
            Richly represents the signature of a callsite.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._infos">
            <summary>
            Array of additional meta information about the arguments, such as named arguments.
            Null for a simple signature that's just an expression list. eg: foo(a*b,c,d)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._argumentCount">
            <summary>
            Number of arguments in the signature.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.HasKeywordArgument">
            <summary>
            True if the OldCallAction includes an ArgumentInfo of ArgumentKind.Dictionary or ArgumentKind.Named.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.GetProvidedPositionalArgumentCount">
            <summary>
            Gets the number of positional arguments the user provided at the call site.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSignature.IsSimple">
            <summary>
            All arguments are unnamed and matched by position. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CustomTracker">
            <summary>
            A custom member tracker which enables languages to plug in arbitrary
            members into the lookup process.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorInfo">
            <summary>
            Encapsulates information about the result that should be produced when 
            a OldDynamicAction cannot be performed.  The ErrorInfo can hold one of:
                an expression which creates an Exception to be thrown 
                an expression which produces a value which should be returned 
                    directly to the user and represents an error has occured (for
                    example undefined in JavaScript)
                an expression which produces a value which should be returned
                    directly to the user but does not actually represent an error.
            
            ErrorInfo's are produced by an ActionBinder in response to a failed
            binding.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.#ctor(Microsoft.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ErrorInfoKind)">
            <summary>
            Private constructor - consumers must use static From* factories
            to create ErrorInfo objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromException(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents an exception that should
            be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValue(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents a value which should be
            returned to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValueNoError(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Crates a new ErrorInfo which represents a value which should be returned
            to the user but does not represent an error.
            </summary>
            <param name="resultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.MakeErrorForRule(Microsoft.Scripting.Actions.RuleBuilder,Microsoft.Scripting.Actions.ActionBinder)">
            <summary>
            Internal helper to produce the actual expression used for the error when emitting
            the error into a rule.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Exception">
            <summary>
            The ErrorInfo expression produces an exception
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Error">
            <summary>
            The ErrorInfo expression produces a value which represents the error (e.g. undefined)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Success">
            <summary>
            The ErrorInfo expression produces a value which is not an error
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.EventTracker.IsStatic">
            <summary>
            Doesn't need to check PrivateBinding setting: no method that is part of the event is public the entire event is private. 
            If the code has already a reference to the event tracker instance for a private event its "static-ness" is not influenced 
            by private-binding setting.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExtensionMethodTracker">
            <summary>
            Represents extension method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ExtensionMethodTracker._declaringType">
            <summary>
            The declaring type of the extension (the type this extension method extends)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExtensionMethodTracker.DeclaringType">
            <summary>
            The declaring type of the extension method. Since this is an extension method,
            the declaring type is in fact the type this extension method extends,
            not Method.DeclaringType
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.PropertyTracker">
            <summary>
            Represents a logical Property as a member of a Type.  This Property can either be a real 
            concrete Property on a type (implemented with a ReflectedPropertyTracker) or an extension
            property (implemented with an ExtensionPropertyTracker).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberGroup">
            <summary>
            MemberGroups are a collection of MemberTrackers which are commonly produced
            on-demand to talk about the available members.  They can consist of a mix of
            different member types or multiple membes of the same type.
            
            The most common source of MemberGroups is from ActionBinder.GetMember.  From here
            the DLR will perform binding to the MemberTrackers frequently producing the value
            resulted from the user.  If the result of the action produces a member it's self
            the ActionBinder can provide the value exposed to the user via ReturnMemberTracker.
            
            ActionBinder provides default functionality for both getting members from a type
            as well as exposing the members to the user.  Getting members from the type maps
            closely to reflection and exposing them to the user exposes the MemberTrackers
            directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MethodGroup">
            <summary>
            MethodGroup's represent a unique collection of method's.  Typically this
            unique set is all the methods which are overloaded by the same name including
            methods with different arity.  These methods represent a single logically
            overloaded element of a .NET type.
            
            The base DLR binders will produce MethodGroup's when provided with a MemberGroup
            which contains only methods.  The MethodGroup's will be unique instances per
            each unique group of methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MethodGroup.MakeGenericMethod(System.Type[])">
            <summary>
            Returns a BuiltinFunction bound to the provided type arguments.  Returns null if the binding
            cannot be performed.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker">
            <summary>
            NamespaceTracker represent a CLS namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IOldDynamicObject">
            <summary>
            Old dynamic interop protocol. Will be removed soon.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IMembersList">
            <summary>
            Provides a list of all the members of an instance.  ie. all the keys in the 
            dictionary of the object. Note that it can contain objects that are not strings. 
            
            Such keys can be added in IronPython using syntax like:
                obj.__dict__[100] = someOtherObject
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.LoadAllTypes">
            <summary>
            Loads all the types from all assemblies that contribute to the current namespace (but not child namespaces)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.GetOrMakePackageHierarchy(System.Reflection.Assembly,System.String)">
            <summary>
            Populates the tree with nodes for each part of the namespace
            </summary>
            <param name="assem"></param>
            <param name="fullNamespace">Full namespace name. It can be null (for top-level types)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.CheckForUnlistedType(System.String)">
            <summary>
            As a fallback, so if the type does exist in any assembly. This would happen if a new type was added
            that was not in the hardcoded list of types. 
            This code is not accurate because:
            1. We dont deal with generic types (TypeCollision). 
            2. Previous calls to GetCustomMemberNames (eg. "from foo import *" in Python) would not have included this type.
            3. This does not deal with new namespaces added to the assembly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker.TypeNames">
            <summary>
            This stores all the public non-nested type names in a single namespace and from a single assembly.
            This allows inspection of the namespace without eagerly loading all the types. Eagerly loading
            types slows down startup, increases working set, and is semantically incorrect as it can trigger
            TypeLoadExceptions sooner than required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeTracker.op_Implicit(Microsoft.Scripting.Actions.TypeTracker)~System.Type">
            <summary>
            Enables implicit Type to TypeTracker conversions accross dynamic languages.
            
            TODO: Should be explicit, but that breaks a JS test
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleBuilder">
            <summary>
            Rule Builder
            
            A rule is the mechanism that LanguageBinders use to specify both what code to execute (the Target)
            for a particular action on a particular set of objects, but also a Test that guards the Target.
            Whenver the Test returns true, it is assumed that the Target will be the correct action to
            take on the arguments.
            
            In the current design, a RuleBuilder is also used to provide a mini binding scope for the
            parameters and temporary variables that might be needed by the Test and Target.  This will
            probably change in the future as we unify around the notion of Lambdas.
            
            TODO: remove once everyone is converted over to MetaObjects
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.RuleBuilder._binding">
            <summary>
            Completed rule
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.RuleBuilder.GetTemporary(System.Type,System.String)">
            <summary>
            Allocates a temporary variable for use during the rule.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Test">
            <summary>
            An expression that should return true if and only if Target should be executed
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Target">
            <summary>
            The code to execute if the Test is true.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.Parameters">
            <summary>
            Gets the logical parameters to the dynamic site in the form of Expressions.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.RuleBuilder.ParameterCount">
            <summary>
            Gets the number of logical parameters the dynamic site is provided with.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TopNamespaceTracker">
            <summary>
            Represents the top reflected package which contains extra information such as
            all the assemblies loaded and the built-in modules.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.TryGetPackage(System.String)">
            <summary>
            returns the package associated with the specified namespace and
            updates the associated module to mark the package as imported.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.LoadAssembly(System.Reflection.Assembly)">
            <summary>
            Ensures that the assembly is loaded
            </summary>
            <param name="assem"></param>
            <returns>true if the assembly was loaded for the first time. 
            false if the assembly had already been loaded before</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.PublishComTypes(System.Reflection.Assembly)">
            <summary>
            When an (interop) assembly is loaded, we scan it to discover the GUIDs of COM interfaces so that we can
            associate the type definition with COM objects with that GUID.
            Since scanning all loaded assemblies can be expensive, in the future, we might consider a more explicit 
            user binder to trigger scanning of COM types.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Constructor">
            <summary> Specifies that the member is a constructor, representing a ConstructorTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Event">
            <summary> Specifies that the member is an event, representing a EventTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Field">
            <summary> Specifies that the member is a field, representing a FieldTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Method">
            <summary> Specifies that the member is a method, representing a MethodTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Property">
            <summary> Specifies that the member is a property, representing a PropertyTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Type">
            <summary> Specifies that the member is a property, representing a TypeTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Namespace">
            <summary> Specifies that the member is a namespace, representing a NamespaceTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.MethodGroup">
            <summary> Specifies that the member is a group of method overloads, representing a MethodGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.TypeGroup">
            <summary> Specifies that the member is a group of types that very by arity, representing a TypeGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Custom">
            <summary> Specifies that the member is a custom meber, represetning a CustomTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Bound">
            <summary> Specifies that the member is a bound to an instance, representing a BoundMemberTracker</summary>        
        </member>
        <member name="T:Microsoft.Scripting.Actions.TypeGroup">
            <summary>
            A TypeCollision is used when we have a collsion between
            two types with the same name.  Currently this is only possible w/ generic
            methods that should logically have arity as a portion of their name. For eg:
                 System.EventHandler and System.EventHandler[T]
                 System.Nullable and System.Nullable[T]
                 System.IComparable and System.IComparable[T]
            
            The TypeCollision provides an indexer but also is a real type.  When used
            as a real type it is the non-generic form of the type.
            
            The indexer allows the user to disambiguate between the generic and
            non-generic versions.  Therefore users must always provide additional
            information to get the generic version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.UpdateTypeEntity(Microsoft.Scripting.Actions.TypeTracker,Microsoft.Scripting.Actions.TypeTracker)">
            <param name="existingTypeEntity">The merged list so far. Could be null</param>
            <param name="newType">The new type(s) to add to the merged list</param>
            <returns>The merged list.  Could be a TypeTracker or TypeGroup</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetGenericArity(System.Type)">
            <summary> Gets the arity of generic parameters</summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.NonGenericType">
            <summary>
            This will throw an exception if all the colliding types are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.DeclaringType">
            <summary>
            This returns the DeclaringType of all the types in the TypeGroup
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Name">
            <summary>
            This returns the base name of the TypeGroup (the name shared by all types minus arity)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Type">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.IsPublic">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.CodeContextExpression">
            <summary>
            Evaluates to the CodeContext that's currently in scope
            
            TODO: this should go away as an intrinsic in favor of languages
                  tracking their own scope chain explicitly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.CodeContextScopeExpression">
            <summary>
            Creates a new scope where the specified CodeContext will be valid
            
            TODO: this should go away as an intrinsic in favor of languages
                  tracking their own scope chain explicitly
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.CodeContextScopeExpression.Body">
            <summary>
            The body where the new CodeContext can be used
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.CodeContextScopeExpression.NewContext">
            <summary>
            The expression that initializes the new CodeContext for this scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GlobalVariableExpression">
            <summary>
            Represents a variable accessed from the host's scope
            Note: this node isn't reducible; it needs a tree rewrite to work
            See GlobalsRewriter
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GlobalVariableExpression.IsLocal">
            <summary>
            If using dynamic lookup, indicates that the variable should be
            looked up in the innermost Scope rather than the top level scope
            
            TODO: Python specific, can it be removed?
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsConstructor(System.Reflection.MethodBase)">
            <summary>
            True if the MethodBase is method which is going to construct an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsSealed(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetType(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTypes(System.Object[])">
            <summary>
            Simply returns a Type[] from calling GetType on each element of args.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TryGetCallableMethod(System.Reflection.MethodInfo)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Returns the original method if the method if a public version cannot be found.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.FilterNonVisibleMembers(System.Type,System.Reflection.MemberInfo[])">
            <summary>
            Non-public types can have public members that we find when calling type.GetMember(...).  This
            filters out the non-visible members by attempting to resolve them to the correct visible type.
            
            If no correct visible type can be found then the member is not visible and we won't call it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetCallableMethod(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Throws InvalidOperationException if the method cannot be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTryConvertReturnValue(Microsoft.Scripting.Runtime.CodeContext,Microsoft.Scripting.Actions.RuleBuilder)">
            <summary>
            Returns a value which indicates failure when a ConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile(Microsoft.Linq.Expressions.LambdaExpression)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile``1(Microsoft.Linq.Expressions.Expression{``0})">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <typeparam name="T">The lambda's delegate type.</typeparam>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Compile``1(Microsoft.Linq.Expressions.Expression{``0},System.Boolean)">
            <summary>
            Compiles the LambdaExpression.
            
            If the lambda is compiled with emitDebugSymbols, it will be
            generated into a TypeBuilder. Otherwise, this method is the same as
            calling LambdaExpression.Compile()
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="emitDebugSymbols">true to generate a debuggable method, false otherwise</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.CompileToMethod``1(Microsoft.Linq.Expressions.Expression{``0},System.Boolean)">
            <summary>
            Compiles the LambdaExpression, emitting it into a new type, and
            optionally making it debuggable.
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="emitDebugSymbols">true to generate a debuggable method, false otherwise</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Reduce(Microsoft.Linq.Expressions.DynamicExpression)">
            <summary>
            Reduces the provided DynamicExpression into site.Target(site, *args).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.CompilerHelpers.BoundConstantsRewriter">
            <summary>
            Removes all live objects and places them in static fields of a type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalArrayRewriter">
            <summary>
            Rewrites globals to elements on a closed over array
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalRewriter">
            <summary>
            Rewrites known extension nodes into primitive ones:
              * GlobalVariableExpression
              * CodeContextExpression
              * CodeContextScopeExpression
              
            TODO: remove all of the functionality related to CodeContext, once
            Python and JS fix their scope implementations to and the CodeContext*
            nodes go away. All that should be left is global support, and even that
            can go once OptimizedModules moves into Python.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalLookupRewriter">
            <summary>
            Converts globals to late bound lookups on the scope
            TODO: move to IronPython
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.GlobalStaticFieldRewriter">
            <summary>
            Rewrites globals to static fields on a type
            Also rewrites constants to static fields
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ParameterInfoWrapper">
            <summary>
            This helper type lets us build a fake ParameterInfo object with a specific type and name
            to pass along to methods that expect ParameterInfos.  This is currently found useful
            for the NewTypeMaker code and may be useful in other situations as well.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ToDiskRewriter">
            <summary>
            Serializes constants and dynamic sites so the code can be saved to disk
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Normal">
            <summary>
            The MethodBinder will perform normal method binding.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.BinaryOperator">
            <summary>
            The MethodBinder will return the languages definition of NotImplemented if the arguments are
            incompatible with the signature.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Constructor">
            <summary>
            The MethodBinder will set properties/fields for unused keyword arguments on the instance 
            that gets returned from the method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrMainCallTarget">
            <summary>
            The delegate representing the DLR Main function
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CodeContext">
            <summary>
            TODO: Rename to LocalScope
            </summary>    
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ContextId">
            <summary>
            Represents a language context.  Typically there is at most 1 context 
            associated with each language, but some languages may use more than one context
            to identify code that should be treated differently.  Contexts are used during
            member and operator lookup.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ContextId.RegisterContext(System.Object)">
            <summary>
            Registers a language within the system with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ContextId.LookupContext(System.Object)">
            <summary>
            Looks up the context ID for the specified context identifier
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrCachedCodeAttribute">
            <summary>
            An attribute that is applied to saved ScriptCode's to be used to re-create the ScriptCode
            from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CachedOptimizedCodeAttribute.Names">
            <summary>
            Gets names stored in optimized scope. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DocumentationAttribute">
            <summary>
            Provides a mechanism for providing documentation stored in an assembly as metadata.  
            
            Applying this attribute will enable documentation to be provided to the user at run-time
            even if XML Docuementation files are unavailable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicStackFrame">
            <summary>
            Helper for storing information about stack frames.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExceptionHelpers">
            <summary>
            These are some generally useful helper methods for handling exceptions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ExceptionHelpers._caughtExceptions">
            <summary>
            Keeps track of exceptions being handled in interpreted mode (so we can support rethrow statements).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.UpdateForRethrow(System.Exception)">
            <summary>
            Updates an exception before it's getting re-thrown so
            we can present a reasonable stack trace to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetExceptionStackTraces(System.Exception)">
            <summary>
            Returns all the stack traces associates with an exception
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.UpdateStackTraceForRethrow(System.Exception,System.Reflection.MethodBase,System.String,System.String,System.Int32)">
            <summary>
            Does AssociateDynamicStackFrames, UpdateStackTrace, followed by UpdateForRethrow.
            Used so we only have to codegen one helper call in LightLambdaClosureVisitor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetStackFrames(System.Exception)">
            <summary>
            Walks all stack frames, filtering out DLR frames
            Does not walk the frames in the InnerException, if any
            Frames are returned in CLR order (inner to outer)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetStackFrames(System.Exception,System.Boolean)">
            <summary>
            Walks all stack frames, filtering out DLR frames
            Does not walk the frames in the InnerException, if any
            Frames are returned in CLR order (inner to outer), unless reverse is set
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExceptionHelpers.CurrentExceptions">
            <summary>
            Gets the list of exceptions that are currently being handled by the user. 
            
            These represent active catch blocks on the stack.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExtensionTypeAttribute">
            <summary>
            Marks a class in the assembly as being an extension type for another type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Marks a type in the assembly as being an extension type for another type.
            </summary>
            <param name="extends">The type which is being extended</param>
            <param name="extensionType">The type which provides the extension members.</param>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.ExtensionType">
            <summary>
            The type which contains extension members which are added to the type being extended.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.Extends">
            <summary>
            The type which is being extended by the extension type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CheckedDictionaryEnumerator">
            <summary>
            Not all .NET enumerators throw exceptions if accessed in an invalid state. This type
            can be used to throw exceptions from enumerators implemented in IronPython.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IModuleDictionaryInitialization">
            <summary>
            Intended for internal use to initialization optimized module dictionaries.  Exposed publicly because 
            generated types implement this interface.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.GlobalsDictionary">
            <summary>
            Dictionary backed by an array used for collectable globals. See also
            GlobalArrayRewriter
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeEventArgs">
            <summary>
            Event args for when a ScriptScope has had its contents changed.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(Microsoft.Scripting.SymbolId,Microsoft.Scripting.Runtime.ModuleChangeType)">
            <summary>
            Creates a new ModuleChangeEventArgs object with the specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(Microsoft.Scripting.SymbolId,Microsoft.Scripting.Runtime.ModuleChangeType,System.Object)">
            <summary>
            Creates a nwe ModuleChangeEventArgs with the specified name, type, and changed value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Name">
            <summary>
            Gets the name of the symbol that has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.ChangeType">
            <summary>
            Gets the way in which the symbol has changed: Set or Delete.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Value">
            <summary>
            The the symbol has been set provides the new value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeType">
            <summary>
            The way in which a module has changed : Set or Delete
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Set">
            <summary>
            A new value has been set in the module (or a previous value has changed).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Delete">
            <summary>
            A value has been removed from the module.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleGlobalCache">
            <summary>
            Cached global value.  Created and maintained on a per-language basis.  Default
            implementation returns a singleton which indicates caching is not occuring.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleGlobalCache.#ctor(System.Object)">
            <summary>
            Creates a new ModuleGlobalCache with the specified value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleGlobalCache.Changed(System.Object,Microsoft.Scripting.Runtime.ModuleChangeEventArgs)">
            <summary>
            Event handler for when the value has changed.  Language implementors should call this when
            the cached value is invalidated.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.IsCaching">
            <summary>
            True if the ModuleGlobalCache is participating in a caching strategy.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.HasValue">
            <summary>
            True if their is currently a value associated with this global variable.  False if
            it is currently unassigned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleGlobalCache.Value">
            <summary>
            Gets or sets the current cached value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleGlobalWrapper">
            <summary>
            Provides cached global variable for modules to enable optimized access to
            module globals.  Both the module global value and the cached value can be held
            onto and the cached value can be invalidated by the providing LanguageContext.
            
            The cached value is provided by the LanguageContext.GetModuleCache API.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NotNullAttribute">
            <summary>
            This attribute marks a parameter that is not allowed to be null.
            It is used by the method binding infrastructure to generate better error 
            messages and method selection.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NullTextContentProvider">
            <summary>
            A NullTextContentProvider to be provided when we have a pre-compiled ScriptCode which doesn't
            have source code associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperationFailed">
            <summary>
            Singleton instance returned from an operator method when the operator method cannot provide a value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperatorSlotAttribute">
            <summary>
            Represents an ops-extension method which is added as an operator.
            
            The name must be a well-formed name such as "Add" that matches the CLS
            naming conventions for adding overloads associated with op_* methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Operators">
            <summary>
            Enum representing different types of operators.
            
            Operators can be Unary, Binary, or Ternary.  An individual operator can have one or 
            more arity.  
            
            Each operator is associated with a standard name.  If a method is named using the standard
            name and is marked with OperatorMethodAttribute then the method will automatically be
            detected as an operator.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Call">
            <summary>
            Binary operator.
            
            Attempt to call the object.  Arguments are the object and the arguments for the call.  The
            arguments for the call can either be an object array (normal call) or a KwCallInfo class for
            performing a keyword based call.
            
            The standard name for this operator is "Call".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.CodeRepresentation">
            <summary>
            Unary operator.
            
            Returns a string which defines the object in code or a language specific format for
            objects which cannot be represented in code.  This operator generally is not used in
            a non-language specific scenario.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.MemberNames">
            <summary>
            Unary operator.
            
            Gets the list of members that belong to the current object returned as an IList of string
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Documentation">
            <summary>
            Unary operator.
            
            Gets various documentation about the object returned as a string
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.CallSignatures">
            <summary>
            Unary operator.
            
            Gets information about the type of parameters, returned as a string.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.IsCallable">
            <summary>
            Unary operator.
            
            Checks whether the object is callable or not, returns true if it is.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Add">
            <summary>Operator for performing add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Subtract">
            <summary>Operator for performing sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Power">
            <summary>Operator for performing pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Multiply">
            <summary>Operator for performing mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.FloorDivide">
            <summary>Operator for performing floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Divide">
            <summary>Operator for performing div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.TrueDivide">
            <summary>Operator for performing truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Mod">
            <summary>Operator for performing mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LeftShift">
            <summary>Operator for performing lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.RightShift">
            <summary>Operator for performing rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.BitwiseAnd">
            <summary>Operator for performing and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.BitwiseOr">
            <summary>Operator for performing or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ExclusiveOr">
            <summary>Operator for performing xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThan">
            <summary>Operator for performing lt</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GreaterThan">
            <summary>Operator for performing gt</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThanOrEqual">
            <summary>Operator for performing le</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GreaterThanOrEqual">
            <summary>Operator for performing ge</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Equals">
            <summary>Operator for performing eq</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.NotEquals">
            <summary>Operator for performing ne</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.LessThanGreaterThan">
            <summary>Operator for performing lg</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceAdd">
            <summary>Operator for performing in-place add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceSubtract">
            <summary>Operator for performing in-place sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlacePower">
            <summary>Operator for performing in-place pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceMultiply">
            <summary>Operator for performing in-place mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceFloorDivide">
            <summary>Operator for performing in-place floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceDivide">
            <summary>Operator for performing in-place div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceTrueDivide">
            <summary>Operator for performing in-place truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceMod">
            <summary>Operator for performing in-place mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceLeftShift">
            <summary>Operator for performing in-place lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceRightShift">
            <summary>Operator for performing in-place rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceBitwiseAnd">
            <summary>Operator for performing in-place and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceBitwiseOr">
            <summary>Operator for performing in-place or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.InPlaceExclusiveOr">
            <summary>Operator for performing in-place xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseAdd">
            <summary>Operator for performing reverse add</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseSubtract">
            <summary>Operator for performing reverse sub</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReversePower">
            <summary>Operator for performing reverse pow</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseMultiply">
            <summary>Operator for performing reverse mul</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseFloorDivide">
            <summary>Operator for performing reverse floordiv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseDivide">
            <summary>Operator for performing reverse div</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseTrueDivide">
            <summary>Operator for performing reverse truediv</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseMod">
            <summary>Operator for performing reverse mod</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseLeftShift">
            <summary>Operator for performing reverse lshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseRightShift">
            <summary>Operator for performing reverse rshift</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseBitwiseAnd">
            <summary>Operator for performing reverse and</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseBitwiseOr">
            <summary>Operator for performing reverse or</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseExclusiveOr">
            <summary>Operator for performing reverse xor</summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Contains">
            <summary>
            Binary operator.
            
            Checks to see if the instance contains another object.  Returns true or false.
            
            The standard name for this operator is "Contains".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetItem">
            <summary>
            n-ary operator.
            
            Gets the value at the specified index from the instance.
            
            One or more indexes can be provided as individual arguments.
            Obsolete: Use GetIndexAction instead
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetItem">
            <summary>
            n-ary operator.
            
            Sets the value at the specified index in the instance.
            
            One or more indexes can be provided as individual arguments.  The last value provided is the value to be set.
            Obsolete: Use SetIndexAction instead
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteItem">
            <summary>
            n-ary operator.
            
            Removes the item from the specified index in the instance.
            
            One or more indexes can be provided as individual arguments.
            Obsolete: Use DeleteIndexAction instead
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetSlice">
            <summary>
            Binary or Ternary operator.
            
            Gets the specified range of elements (slice) from the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step value is optional.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetSlice">
            <summary>
            n-ary operator.
            
            Sets the specified range of elements in the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step
            value is optional.  The last parameter is the value to be assigned.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteSlice">
            <summary>
            n-ary operator.
            
            Removes the specified range of elements from the instance.
            
            The slice parameters may include the start index, the end index, and the step value.  The step value is
            optional.
            
            A value of Type.Missing may be provided if no parameter was explicitly provided for a start, stop or step parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Length">
            <summary>
            Unary operator.
            
            Returns the number of items stored in the object.
            </summary>      
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Compare">
            <summary>
            Binary operator.
            
            Compares two instances returning an integer indicating the relationship between them.  May
            throw if the object types are uncomparable.
            
            The standard name for this operator is "Compare".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DivMod">
            <summary>
            Binary operator.
            
            Returns both the dividend and quotioent of x / y.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.ReverseDivMod">
            <summary>
            Binary operator.
            
            Returns both the dividend and quotient of y / x.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetMember">
            <summary>
            Member lookup customization (called after type lookup).
            
            Arguments are the instance to get the member from and a SymbolId which represents the member.
            
            The return value is the member.
            
            The standard name for this operator is "GetMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetBoundMember">
            <summary>
            Member lookup customization for bound attributes
            
            Arguments are the instance to get the member from and a SymbolId which represents the bound member.
            
            The return value is the bound member.
            
            /// The standard name for this operator is "GetBoundMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.SetMember">
            <summary>
            Member set customization.
            
            Arguments are the instance, the SymbolId to get, and the new value for the member.
            
            The return value is ignored.
            
            The standard name for this operator is "SetMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.DeleteMember">
            <summary>
            Member delete customization.
            
            Arguments are the instance and the SymbolId for the member to delete.
            
            The return value is ignored.
            
            The standard name for this operator is "DeleteMember".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.GetMemberNames">
            <summary>
            Attribute customization operator.  Returns a list of names that should be displayed as
            being part of the object.
            
            Arguments are the instance to get the list of member names from.
            
            Return value is IList&lt;SymbolId&gt;.
            
            /// The standard name for this operator is "GetMemberNames".
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.AbsoluteValue">
            <summary>
            Unary operator.
            
            Get the absolute value of the instance.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Positive">
            <summary>
            Unary operator.
            
            Gets the positive value of the instance.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.Negate">
            <summary>
            Unary operator.
            
            Negates the instance and return the new value.
            </summary>        
        </member>
        <member name="F:Microsoft.Scripting.Runtime.Operators.OnesComplement">
            <summary>
            Unary operator.
            
            Returns the ones complement of the instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.OptimizedScriptCode.CompileOptimizedScope">
            <summary>
            Creates the methods and optimized Scope's which get associated with each ScriptCode.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PropertyMethodAttribute">
            <summary>
            Represents an ops-extension method which is used to implement a property.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache">
            <summary>
            Provides a cache of reflection members.  Only one set of values is ever handed out per a 
            specific request.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ReflectionCache.GetMethodGroup(System.Type,System.String,System.Reflection.BindingFlags,System.Reflection.MemberFilter)">
            <summary>
            Gets a singleton method group from the provided type.
            
            The provided method group will be unique based upon the methods defined, not based upon the type/name
            combination.  In other words calling GetMethodGroup on a base type and a derived type that introduces
            no new methods under a given name will result in the same method group for both types.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache.MethodBaseCache">
            <summary>
            TODO: Make me private again
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope">
            <summary>
            Represents a context of execution.  A context of execution has a set of variables
            associated with it (its dictionary) and a parent context.  
            
            When looking up a name from a context first the local context is searched.  If the
            name is not found there the name lookup will be done against the parent context.
            
            Scopes can have language-sensitive variables that are only exposed to a single
            language based upon its calling context.  When searching the
            language-sensitive dictionary is searched first.  If no matches are found the lookup
            is delegated back to the LanguageContext.  If the LanguageContext fails to lookup
            the name it delegates back to the (Host or ScriptRuntime?)
            
            Each member of the Scope can optionally have a certain set of attributes associated
            with it (ScopeMemberAttributes).  These permit members of the scope to be read-only,
            non-deletable, or hidden from enumeration.
            
            Scopes, like IAttrbibuteCollections, support both being indexed by SymbolId for fast
            access as well as being indexed by object.  The preferred access is via SymbolId and
            object access is provided for languages which require additional semantics.  All
            features supported for feature IDs are also supported for objects (e.g. context-sentsitivity
            and attributes) but the object API does not contain all the same sets of overloads provided
            for convenience.
            
            TODO: Thread safety
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor">
            <summary>
            Creates a new top-level scope with a new empty dictionary.  The scope
            is marked as being visible.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.IAttributesCollection)">
            <summary>
            Creates a new top-level Scope with the provided dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.IAttributesCollection)">
            <summary>
            Creates a new Scope with the provided parent and dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.#ctor(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.IAttributesCollection,System.Boolean)">
            <summary>
            Creates a new Scope with the provided parent, dictionary and visibility.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetKeys(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys available to all languages in addition to those keys
            which are only available to the provided LanguageContext.
            
            Keys marked with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetName(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.  Search includes
            names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetNameForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope's context specific dictionary.  
            Search includes names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupName(Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId,System.Object@)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   Lookup
            includes searching for names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.LookupName(Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.   If the
            name is not defined MissingMemberException is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.LookupName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attempts to lookup the provided name in this scope or any outer scope.  The
            search includes looking for names that are only visible to the provided LanguageContext.
            
            If the name is not defined the language defined MissingName exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.SymbolId,System.Object)">
            <summary>
            Sets the name to the specified value for the current context.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.SymbolId,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets the name to the specified value for the current context.
            
            Provides the ScopeMemberAttributes which should be set on the provided object.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetName(Microsoft.Scripting.Runtime.ContextId,Microsoft.Scripting.SymbolId,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets a name that is only available in the specified context.
            
            Provides the ScopeMemberAttributes which should be set on the provided object.
            </summary>
            <exception cref="T:System.MemberAccessException">The name has already been published and marked as ReadOnly</exception>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.Clear">
            <summary>
            Removes all members from the dictionary and any context-sensitive dictionaries.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.ContainsName(Microsoft.Scripting.SymbolId)">
            <summary>
            Determines if this context or any outer scope contains the defined name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.ContainsName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Determines if this context or any outer scope contains the defined name that
            is available from the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveName(Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope removing names
            visible to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.RemoveNameForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Removes the provided name from this scope removing names
            visible to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveName(Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveName(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope removing names visible
            to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveForContext(Microsoft.Scripting.Runtime.LanguageContext,Microsoft.Scripting.SymbolId)">
            <summary>
            Attemps to remove the provided name from this scope's context specific dictionary
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryRemoveObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object)">
            <summary>
            Attemps to remove the provided object name from this scope removing names visible
            to both the current context and all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryGetObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object,System.Object@)">
            <summary>
            Trys to lookup the provided name in the current scope.  Search includes
            names that are only visible to the provided LanguageContext.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.TryLookupObjectName(Microsoft.Scripting.Runtime.LanguageContext,System.Object,System.Object@)">
            <summary>
            Attempts to lookup the provided object name in this scope or any outer scope.   Lookup
            includes searching for names that are visible to the provided LanguageContext as well
            as those available to all contexts.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetObjectName(System.Object,System.Object)">
            <summary>
            Sets the name to the specified value for the current context.
            
            The name is an arbitrary object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.SetObjectName(Microsoft.Scripting.Runtime.ContextId,System.Object,System.Object,Microsoft.Scripting.Runtime.ScopeMemberAttributes)">
            <summary>
            Sets the name to the specified value for the current context.
            
            The name is an arbitrary object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetAllKeys(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys available to all languages in addition to those keys
            which are only available to the provided LanguageContext.
            
            Keys marked with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Scope.GetAllItems(Microsoft.Scripting.Runtime.LanguageContext)">
            <summary>
            Returns the list of Keys and Values available to all languages in addition to those
            keys which are only available to the provided LanguageContext.
            
            Keys marked with DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Parent">
            <summary>
            Gets the parent of this Scope or null if the Scope has no parent.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.IsVisible">
            <summary>
            Gets if the context is visible at this scope.  Visibility is a per-language feature that enables
            languages to include members in the Scope chain but hide them when directly exposed to the user.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Keys">
            <summary>
            Returns the list of keys which are available to all languages.  Keys marked with the
            DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Items">
            <summary>
            Returns the list of Keys and Items which are available to all languages.  Keys marked
            with the DontEnumerate flag will not be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.ModuleScope">
            <summary>
            Gets the outer-most scope associated with this scope.  
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.Scope.Dict">
            <summary>
            Default scope dictionary
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope.ContextSensitiveScope">
            <summary>
            Helper class to hold onto all the context-sensitive information for a Scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Scope.ScopeAttributeDictionary">
            <summary>
            Helper class to hold the attributes for both SymbolId and object attributes.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScopeMemberAttributes">
            <summary>
            Common attributes used to control attributes of a Scope.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.None">
            <summary>
            The member has no Scope attributes.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.ReadOnly">
            <summary>
            The member can only be read from and cannot be written to
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.DontDelete">
            <summary>
            The member can be read from or written to but cannot be deleted
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScopeMemberAttributes.DontEnumerate">
            <summary>
            The member can be read or written but is not visible in the displayed list of members.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ScriptDomainManager.Globals">
            <summary>
            A collection of environment variables.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageConfiguration">
            <summary>
            Singleton for each language.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LanguageConfiguration.LoadLanguageContext(Microsoft.Scripting.Runtime.ScriptDomainManager,System.Boolean@)">
            <summary>
            Must not be called under a lock as it can potentially call a user code.
            </summary>
            <exception cref="T:Microsoft.Scripting.Runtime.MissingTypeException"></exception>
            <exception cref="T:Microsoft.Scripting.InvalidImplementationException">The language context's implementation failed to instantiate.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DlrConfiguration.DebugMode">
            <summary>
            Whether the application is in debug mode.
            This means:
            
            1) Symbols are emitted for debuggable methods (methods associated with SourceUnit).
            2) Debuggable methods are emitted to non-collectable types (this is due to CLR limitations on dynamic method debugging).
            3) JIT optimization is disabled for all methods
            4) Languages may disable optimizations based on this value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DlrConfiguration.PrivateBinding">
            <summary>
            Ignore CLR visibility checks.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.SharedIO.SetOutput(System.IO.Stream,System.IO.TextWriter)">
            <summary>
            Only host should redirect I/O.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.StaticExtensionMethodAttribute">
            <summary>
            Indicates an extension method should be added as a static method, not a instance method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.SymbolDictionary">
            <summary>
            Simple thread-safe SymbolDictionary used for storing collections of members.
            
            Like all SymbolDictionaries this supports both indexing using SymbolId's (IAttributesCollection)
            and via object keys (IDictionary&lt;object, object&gt;).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.SymbolDictionary.GetObjectKeysDictionary">
            <summary>
            Symbol dictionaries are usually indexed using literal strings, which is handled using the Symbols.
            However, some languages allow non-string keys too. We handle this case by lazily creating an object-keyed dictionary,
            and keeping it in the symbol-indexed dictionary. Such access is slower, which is acceptable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.TransformDictionaryEnumerator">
            <summary>
            Exposes a IDictionary&lt;SymbolId, object&gt; as a IDictionary&lt;object, object&lt;
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts a generic ICollection of T into an array of T.  
            
            If the collection is already an  array of T the original collection is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Requires the enumerable collection and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DictionaryUnionEnumerator">
            <summary>
            Presents a flat enumerable view of multiple dictionaries
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation_ContainsGenericParameters(System.Object,System.Object)">
            <summary>
            A string like  "Cannot access member {1} declared on type {0} because the type contains generic parameters."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MissingType(System.Object)">
            <summary>
            A string like  "Type '{0}' is missing or cannot be loaded."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAccessFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be read through a type, not an instance"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAssignmentFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be assigned to through a type, not an instance"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnknownMemberType(System.Object)">
            <summary>
            A string like  "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NonGenericWithGenericGroup(System.Object)">
            <summary>
            A string like  "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            A string like  "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoCallableMethods(System.Object,System.Object)">
            <summary>
            A string like  "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExtensionMustBePublic(System.Object)">
            <summary>
            A string like  "Extension type {0} must be public."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            A string like  "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ReferencedBeforeAssignment(System.Object)">
            <summary>
            A string like  "Local variable '{0}' referenced before assignment."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.FieldReadonly(System.Object)">
            <summary>
            A string like  "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.PropertyReadonly(System.Object)">
            <summary>
            A string like  "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExpectedBoundEvent(System.Object)">
            <summary>
            A string like  "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedType(System.Object,System.Object)">
            <summary>
            A string like  "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MemberWriteOnly(System.Object)">
            <summary>
            A string like  "can only write to member {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidStreamType(System.Object)">
            <summary>
            A string like  "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddCasing(System.Object)">
            <summary>
            A string like  "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddIdentifier(System.Object)">
            <summary>
            A string like  "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCtorImplementation(System.Object,System.Object)">
            <summary>
            A string like  "Type '{0}' doesn't provide a suitable public constructor or its implementation is faulty: {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            A string like  "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoImplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoExplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NameNotDefined(System.Object)">
            <summary>
            A string like  "name '{0}' not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.IllegalNew_GenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustBeExceptionInstance">
            <summary>
            A string like  "must by an Exception instance"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfTestMustBeBool">
            <summary>
            A string like  "Type of test must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfExpressionMustBeBool">
            <summary>
            A string like  "Type of the expression must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EmptyStringIsInvalidPath">
            <summary>
            A string like  "Empty string is not a valid path."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidDelegate">
            <summary>
            A string like  "Invalid delegate type (Invoke method not found)."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ExpectedStaticProperty">
            <summary>
            A string like  "expected only static property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.PropertyDoesNotExist">
            <summary>
            A string like  "Property doesn't exist on the provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FieldDoesNotExist">
            <summary>
            A string like  "Field doesn't exist on provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustHaveCodeOrTarget">
            <summary>
            A string like  "Either code or target must be specified."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoInstanceForCall">
            <summary>
            A string like  "no instance for call."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTest">
            <summary>
            A string like  "Missing Test."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTarget">
            <summary>
            A string like  "Missing Target."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FinallyAlreadyDefined">
            <summary>
            A string like  "Finally already defined."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotHaveFaultAndFinally">
            <summary>
            A string like  "Can not have fault and finally."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FaultAlreadyDefined">
            <summary>
            A string like  "Fault already defined."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GlobalsMustBeUnique">
            <summary>
            A string like  "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GenNonSerializableBinder">
            <summary>
            A string like  "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidPath">
            <summary>
            A string like  "pecified path is invalid."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.DictionaryNotHashable">
            <summary>
            A string like  "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.LanguageRegistered">
            <summary>
            A string like  "language already registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodOrOperatorNotImplemented">
            <summary>
            A string like  "The method or operation is not implemented."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoException">
            <summary>
            A string like  "No exception."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.AlreadyInitialized">
            <summary>
            A string like  "Already initialized."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustReturnScopeExtension">
            <summary>
            A string like  "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidParamNumForService">
            <summary>
            A string like  "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotChangeNonCachingValue">
            <summary>
            A string like  "Cannot change non-caching value."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoCodeToCompile">
            <summary>
            A string like  "No code to compile."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationNotStarted">
            <summary>
            A string like  "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationFinished">
            <summary>
            A string like  "Enumeration already finished."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoDefaultValue">
            <summary>
            A string like  "No default value for a given type."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.UnknownLanguageProviderType">
            <summary>
            A string like  "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantReadProperty">
            <summary>
            A string like  "can't read from property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantWriteProperty">
            <summary>
            A string like  "can't write to property"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustHaveCodeOrTarget">
            <summary>
            ArgumentException with message like "Either code or target must be specified."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FirstArgumentMustBeCallSite">
            <summary>
            InvalidOperationException with message like "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoInstanceForCall">
            <summary>
            InvalidOperationException with message like "no instance for call."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTest">
            <summary>
            InvalidOperationException with message like "Missing Test."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTarget">
            <summary>
            InvalidOperationException with message like "Missing Target."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NonGenericWithGenericGroup(System.Object)">
            <summary>
            TypeLoadException with message like "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FinallyAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Finally already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotHaveFaultAndFinally">
            <summary>
            InvalidOperationException with message like "Can not have fault and finally."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FaultAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Fault already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCallableMethods(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GlobalsMustBeUnique">
            <summary>
            ArgumentException with message like "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GenNonSerializableBinder">
            <summary>
            ArgumentException with message like "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidPath">
            <summary>
            ArgumentException with message like "pecified path is invalid."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DictionaryNotHashable">
            <summary>
            ArgumentTypeException with message like "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.LanguageRegistered">
            <summary>
            InvalidOperationException with message like "language already registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MethodOrOperatorNotImplemented">
            <summary>
            NotImplementedException with message like "The method or operation is not implemented."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoException">
            <summary>
            InvalidOperationException with message like "No exception."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExtensionMustBePublic(System.Object)">
            <summary>
            ArgumentException with message like "Extension type {0} must be public."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.AlreadyInitialized">
            <summary>
            InvalidOperationException with message like "Already initialized."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustReturnScopeExtension">
            <summary>
            InvalidImplementationException with message like "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidParamNumForService">
            <summary>
            ArgumentException with message like "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotChangeNonCachingValue">
            <summary>
            ArgumentException with message like "Cannot change non-caching value."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ReferencedBeforeAssignment(System.Object)">
            <summary>
            Microsoft.Scripting.Runtime.UnboundLocalException with message like "Local variable '{0}' referenced before assignment."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FieldReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.PropertyReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExpectedBoundEvent(System.Object)">
            <summary>
            ArgumentTypeException with message like "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedType(System.Object,System.Object)">
            <summary>
            ArgumentTypeException with message like "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MemberWriteOnly(System.Object)">
            <summary>
            MemberAccessException with message like "can only write to member {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCodeToCompile">
            <summary>
            InvalidOperationException with message like "No code to compile."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidStreamType(System.Object)">
            <summary>
            ArgumentException with message like "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationNotStarted">
            <summary>
            InvalidOperationException with message like "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationFinished">
            <summary>
            InvalidOperationException with message like "Enumeration already finished."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddCasing(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddIdentifier(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoImplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoExplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NameNotDefined(System.Object)">
            <summary>
            MissingMemberException with message like "name '{0}' not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoDefaultValue">
            <summary>
            ArgumentException with message like "No default value for a given type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownLanguageProviderType">
            <summary>
            ArgumentException with message like "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantReadProperty">
            <summary>
            InvalidOperationException with message like "can't read from property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantWriteProperty">
            <summary>
            InvalidOperationException with message like "can't write to property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.IllegalNew_GenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekLine(System.IO.TextReader,System.Int32)">
            <summary>
            Seeks the first character of a specified line in the text stream.
            </summary>
            <param name="reader">The reader.</param>
            <param name="line">Line number. The current position is assumed to be line #1.</param>
            <returns>
            Returns <c>true</c> if the line is found, <b>false</b> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.ReadTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters to a string until end position or a terminator is reached. 
            Doesn't include the terminator into the resulting string.
            Returns <c>null</c>, if the reader is at the end position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters until end position or a terminator is reached.
            Returns <c>true</c> if the character has been found (the reader is positioned right behind the character), 
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetDeclaredInterfaces(System.Type)">
            <summary>
            Like Type.GetInterfaces, but only returns the interfaces implemented by this type
            and not its parents.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StringUtils.SplitWords(System.String,System.Boolean,System.Int32)">
            <summary>
            Splits text and optionally indents first lines - breaks along words, not characters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.CompilerOptions">
            <summary>
            Class that represents compiler options.
            Note that this class is likely to change when hosting API becomes part of .Net
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PlatformAdaptationLayer">
            <summary>
            Abstracts system operations that are used by DLR and could potentially be platform specific.
            The host can implement its PAL to adapt DLR to the platform it is running on.
            For example, the Silverlight host adapts some file operations to work against files on the server.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.PlatformAdaptationLayer.GetFullPath(System.String)">
            <exception cref="T:System.ArgumentException">Invalid path.</exception>
        </member>
        <member name="M:Microsoft.Scripting.PlatformAdaptationLayer.IsAbsolutePath(System.String)">
            <exception cref="T:System.ArgumentException">Invalid path.</exception>
        </member>
        <member name="T:Microsoft.Scripting.SourceCodeKind">
            <summary>
            Defines a kind of the source code. The parser sets its initial state accordingly.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.Expression">
            <summary>
            The code is an expression.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.Statements">
            <summary>
            The code is a sequence of statements.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.SingleStatement">
            <summary>
            The code is a single statement.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.File">
            <summary>
            The code is a content of a file.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.InteractiveCode">
            <summary>
            The code is an interactive command.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceCodeKind.AutoDetect">
            <summary>
            The language parser auto-detects the kind. A syntax error is reported if it is not able to do so.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ScriptCodeParseResult.Complete">
            <summary>
            Source code is a syntactically correct.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ScriptCodeParseResult.Empty">
            <summary>
            Source code represents an empty statement/expression.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ScriptCodeParseResult.Invalid">
            <summary>
            Source code is already invalid and no suffix can make it syntactically correct.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ScriptCodeParseResult.IncompleteToken">
            <summary>
            Last token is incomplete. Source code can still be completed correctly.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.ScriptCodeParseResult.IncompleteStatement">
            <summary>
            Last statement is incomplete. Source code can still be completed correctly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.FileStreamContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.GetCodeLines(System.Int32,System.Int32)">
            <summary>
            Reads specified range of lines (or less) from the source unit. 
            Line numbers starts with 1.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Compile(Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.ErrorSink)">
            <summary>
            Errors are reported to the specified sink. 
            Returns <c>null</c> if the parser cannot compile the code due to error(s).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute(Microsoft.Scripting.Runtime.Scope)">
            <summary>
            Executes against a specified scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute(Microsoft.Scripting.Runtime.Scope,Microsoft.Scripting.ErrorSink)">
            <summary>
            Executes against a specified scope and reports errors to the given error sink.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute">
            <summary>
            Executes in a new scope created by the language.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute(Microsoft.Scripting.ErrorSink)">
            <summary>
            Executes in a new scope created by the language.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceUnit.Execute(Microsoft.Scripting.CompilerOptions,Microsoft.Scripting.ErrorSink)">
            <summary>
            Executes in a new scope created by the language.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceUnit.Path">
            <summary>
            Identification of the source unit. Assigned by the host. 
            The format and semantics is host dependent (could be a path on file system or URL).
            Empty string for anonymous source units.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceUnit.LanguageContext">
            <summary>
            LanguageContext of the language of the unit.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceCodeReader">
            <summary>
            Source code reader.
            </summary>    
        </member>
        <member name="M:Microsoft.Scripting.SourceCodeReader.SeekLine(System.Int32)">
            <summary>
            Seeks the first character of a specified line in the text stream.
            </summary>
            <param name="line">Line number. The current position is assumed to be line #1.</param>
            <returns>
            Returns <c>true</c> if the line is found, <b>false</b> otherwise.
            </returns>
        </member>
        <member name="P:Microsoft.Scripting.SourceCodeReader.Encoding">
            <summary>
            Encoding that is used by the reader to convert binary data read from an underlying binary stream.
            <c>Null</c> if the reader is reading from a textual source (not performing any byte to character transcoding).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SymbolId.ToString">
            <summary>
            Override of ToString.
            DO NOT USE THIS METHOD TO RETRIEVE STRING THAT THE SYMBOL REPRESENTS
            Use SymbolTable.IdToString(SymbolId) instead.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SymbolId.Empty">
            <summary>SymbolId for null string</summary>
        </member>
        <member name="F:Microsoft.Scripting.SymbolId.Invalid">
            <summary>SymbolId to represent invalid value</summary>
        </member>
        <member name="P:Microsoft.Scripting.SyntaxErrorException.RawSpan">
            <summary>
            Unmapped span.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.EndOfStream">
            <summary>
            A token marking an end of stream.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.WhiteSpace">
            <summary>
            A space, tab, or newline.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Comment">
            <summary>
            A block comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.LineComment">
            <summary>
            A single line comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.DocComment">
            <summary>
            A documentation comment.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.NumericLiteral">
            <summary>
            A numeric literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.CharacterLiteral">
            <summary>
            A character literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.StringLiteral">
            <summary>
            A string literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.RegularExpressionLiteral">
            <summary>
            A regular expression literal.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Keyword">
            <summary>
            A keyword.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Directive">
            <summary>
            A directive (e.g. #line).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Operator">
            <summary>
            A punctuation character that has a specific meaning in a language.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Delimiter">
            <summary>
            A token that operates as a separator between two language elements.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Identifier">
            <summary>
            An identifier (variable, $variable, @variable, @@variable, $variable$, function!, function?, [variable], i'variable', ...)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Grouping">
            <summary>
            Braces, parenthesis, brackets.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.TokenCategory.Error">
            <summary>
            Errors.
            </summary>
        </member>
    </members>
</doc>
